{"version":3,"sources":["../common/worker/file:/Users/kw/github/monaco-editor-core/out-editor-src/vs/base/common/worker/simpleWorker.ts","../common/worker/vs/base/common/worker/simpleWorker.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../charCode.js';\nimport { onUnexpectedError, transformErrorForSerialization } from '../errors.js';\nimport { Emitter, Event } from '../event.js';\nimport { Disposable, IDisposable } from '../lifecycle.js';\nimport { AppResourcePath, FileAccess } from '../network.js';\nimport { isWeb } from '../platform.js';\nimport * as strings from '../strings.js';\nimport { URI } from '../uri.js';\n\nconst DEFAULT_CHANNEL = 'default';\nconst INITIALIZE = '$initialize';\n\nexport interface IWorker extends IDisposable {\n\tgetId(): number;\n\tpostMessage(message: Message, transfer: ArrayBuffer[]): void;\n}\n\nexport interface IWorkerCallback {\n\t(message: Message): void;\n}\n\nexport interface IWorkerFactory {\n\tcreate(modules: IWorkerDescriptor, callback: IWorkerCallback, onErrorCallback: (err: any) => void): IWorker;\n}\n\nexport interface IWorkerDescriptor {\n\treadonly moduleId: string;\n\treadonly esmModuleLocation: URI | undefined;\n\treadonly label: string | undefined;\n}\n\nlet webWorkerWarningLogged = false;\nexport function logOnceWebWorkerWarning(err: any): void {\n\tif (!isWeb) {\n\t\t// running tests\n\t\treturn;\n\t}\n\tif (!webWorkerWarningLogged) {\n\t\twebWorkerWarningLogged = true;\n\t\tconsole.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\n\t}\n\tconsole.warn(err.message);\n}\n\nconst enum MessageType {\n\tRequest,\n\tReply,\n\tSubscribeEvent,\n\tEvent,\n\tUnsubscribeEvent\n}\nclass RequestMessage {\n\tpublic readonly type = MessageType.Request;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly channel: string,\n\t\tpublic readonly method: string,\n\t\tpublic readonly args: any[]\n\t) { }\n}\nclass ReplyMessage {\n\tpublic readonly type = MessageType.Reply;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly seq: string,\n\t\tpublic readonly res: any,\n\t\tpublic readonly err: any\n\t) { }\n}\nclass SubscribeEventMessage {\n\tpublic readonly type = MessageType.SubscribeEvent;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly channel: string,\n\t\tpublic readonly eventName: string,\n\t\tpublic readonly arg: any\n\t) { }\n}\nclass EventMessage {\n\tpublic readonly type = MessageType.Event;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly event: any\n\t) { }\n}\nclass UnsubscribeEventMessage {\n\tpublic readonly type = MessageType.UnsubscribeEvent;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string\n\t) { }\n}\ntype Message = RequestMessage | ReplyMessage | SubscribeEventMessage | EventMessage | UnsubscribeEventMessage;\n\ninterface IMessageReply {\n\tresolve: (value?: any) => void;\n\treject: (error?: any) => void;\n}\n\ninterface IMessageHandler {\n\tsendMessage(msg: any, transfer?: ArrayBuffer[]): void;\n\thandleMessage(channel: string, method: string, args: any[]): Promise<any>;\n\thandleEvent(channel: string, eventName: string, arg: any): Event<any>;\n}\n\nclass SimpleWorkerProtocol {\n\n\tprivate _workerId: number;\n\tprivate _lastSentReq: number;\n\tprivate _pendingReplies: { [req: string]: IMessageReply };\n\tprivate _pendingEmitters: Map<string, Emitter<any>>;\n\tprivate _pendingEvents: Map<string, IDisposable>;\n\tprivate _handler: IMessageHandler;\n\n\tconstructor(handler: IMessageHandler) {\n\t\tthis._workerId = -1;\n\t\tthis._handler = handler;\n\t\tthis._lastSentReq = 0;\n\t\tthis._pendingReplies = Object.create(null);\n\t\tthis._pendingEmitters = new Map<string, Emitter<any>>();\n\t\tthis._pendingEvents = new Map<string, IDisposable>();\n\t}\n\n\tpublic setWorkerId(workerId: number): void {\n\t\tthis._workerId = workerId;\n\t}\n\n\tpublic sendMessage(channel: string, method: string, args: any[]): Promise<any> {\n\t\tconst req = String(++this._lastSentReq);\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\tthis._pendingReplies[req] = {\n\t\t\t\tresolve: resolve,\n\t\t\t\treject: reject\n\t\t\t};\n\t\t\tthis._send(new RequestMessage(this._workerId, req, channel, method, args));\n\t\t});\n\t}\n\n\tpublic listen(channel: string, eventName: string, arg: any): Event<any> {\n\t\tlet req: string | null = null;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\treq = String(++this._lastSentReq);\n\t\t\t\tthis._pendingEmitters.set(req, emitter);\n\t\t\t\tthis._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis._pendingEmitters.delete(req!);\n\t\t\t\tthis._send(new UnsubscribeEventMessage(this._workerId, req!));\n\t\t\t\treq = null;\n\t\t\t}\n\t\t});\n\t\treturn emitter.event;\n\t}\n\n\tpublic handleMessage(message: Message): void {\n\t\tif (!message || !message.vsWorker) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._workerId !== -1 && message.vsWorker !== this._workerId) {\n\t\t\treturn;\n\t\t}\n\t\tthis._handleMessage(message);\n\t}\n\n\tpublic createProxyToRemoteChannel<T extends object>(channel: string, sendMessageBarrier?: () => Promise<void>): T {\n\t\tconst handler = {\n\t\t\tget: (target: any, name: PropertyKey) => {\n\t\t\t\tif (typeof name === 'string' && !target[name]) {\n\t\t\t\t\tif (propertyIsDynamicEvent(name)) { // onDynamic...\n\t\t\t\t\t\ttarget[name] = (arg: any): Event<any> => {\n\t\t\t\t\t\t\treturn this.listen(channel, name, arg);\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (propertyIsEvent(name)) { // on...\n\t\t\t\t\t\ttarget[name] = this.listen(channel, name, undefined);\n\t\t\t\t\t} else if (name.charCodeAt(0) === CharCode.DollarSign) { // $...\n\t\t\t\t\t\ttarget[name] = async (...myArgs: any[]) => {\n\t\t\t\t\t\t\tawait sendMessageBarrier?.();\n\t\t\t\t\t\t\treturn this.sendMessage(channel, name, myArgs);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target[name];\n\t\t\t}\n\t\t};\n\t\treturn new Proxy(Object.create(null), handler);\n\t}\n\n\tprivate _handleMessage(msg: Message): void {\n\t\tswitch (msg.type) {\n\t\t\tcase MessageType.Reply:\n\t\t\t\treturn this._handleReplyMessage(msg);\n\t\t\tcase MessageType.Request:\n\t\t\t\treturn this._handleRequestMessage(msg);\n\t\t\tcase MessageType.SubscribeEvent:\n\t\t\t\treturn this._handleSubscribeEventMessage(msg);\n\t\t\tcase MessageType.Event:\n\t\t\t\treturn this._handleEventMessage(msg);\n\t\t\tcase MessageType.UnsubscribeEvent:\n\t\t\t\treturn this._handleUnsubscribeEventMessage(msg);\n\t\t}\n\t}\n\n\tprivate _handleReplyMessage(replyMessage: ReplyMessage): void {\n\t\tif (!this._pendingReplies[replyMessage.seq]) {\n\t\t\tconsole.warn('Got reply to unknown seq');\n\t\t\treturn;\n\t\t}\n\n\t\tconst reply = this._pendingReplies[replyMessage.seq];\n\t\tdelete this._pendingReplies[replyMessage.seq];\n\n\t\tif (replyMessage.err) {\n\t\t\tlet err = replyMessage.err;\n\t\t\tif (replyMessage.err.$isError) {\n\t\t\t\terr = new Error();\n\t\t\t\terr.name = replyMessage.err.name;\n\t\t\t\terr.message = replyMessage.err.message;\n\t\t\t\terr.stack = replyMessage.err.stack;\n\t\t\t}\n\t\t\treply.reject(err);\n\t\t\treturn;\n\t\t}\n\n\t\treply.resolve(replyMessage.res);\n\t}\n\n\tprivate _handleRequestMessage(requestMessage: RequestMessage): void {\n\t\tconst req = requestMessage.req;\n\t\tconst result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);\n\t\tresult.then((r) => {\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, r, undefined));\n\t\t}, (e) => {\n\t\t\tif (e.detail instanceof Error) {\n\t\t\t\t// Loading errors have a detail property that points to the actual error\n\t\t\t\te.detail = transformErrorForSerialization(e.detail);\n\t\t\t}\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e)));\n\t\t});\n\t}\n\n\tprivate _handleSubscribeEventMessage(msg: SubscribeEventMessage): void {\n\t\tconst req = msg.req;\n\t\tconst disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {\n\t\t\tthis._send(new EventMessage(this._workerId, req, event));\n\t\t});\n\t\tthis._pendingEvents.set(req, disposable);\n\t}\n\n\tprivate _handleEventMessage(msg: EventMessage): void {\n\t\tif (!this._pendingEmitters.has(msg.req)) {\n\t\t\tconsole.warn('Got event for unknown req');\n\t\t\treturn;\n\t\t}\n\t\tthis._pendingEmitters.get(msg.req)!.fire(msg.event);\n\t}\n\n\tprivate _handleUnsubscribeEventMessage(msg: UnsubscribeEventMessage): void {\n\t\tif (!this._pendingEvents.has(msg.req)) {\n\t\t\tconsole.warn('Got unsubscribe for unknown req');\n\t\t\treturn;\n\t\t}\n\t\tthis._pendingEvents.get(msg.req)!.dispose();\n\t\tthis._pendingEvents.delete(msg.req);\n\t}\n\n\tprivate _send(msg: Message): void {\n\t\tconst transfer: ArrayBuffer[] = [];\n\t\tif (msg.type === MessageType.Request) {\n\t\t\tfor (let i = 0; i < msg.args.length; i++) {\n\t\t\t\tif (msg.args[i] instanceof ArrayBuffer) {\n\t\t\t\t\ttransfer.push(msg.args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (msg.type === MessageType.Reply) {\n\t\t\tif (msg.res instanceof ArrayBuffer) {\n\t\t\t\ttransfer.push(msg.res);\n\t\t\t}\n\t\t}\n\t\tthis._handler.sendMessage(msg, transfer);\n\t}\n}\n\ntype ProxiedMethodName = (`$${string}` | `on${string}`);\n\nexport type Proxied<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R\n\t? (\n\t\tK extends ProxiedMethodName\n\t\t? (...args: A) => Promise<Awaited<R>>\n\t\t: never\n\t)\n\t: never\n};\n\nexport interface IWorkerClient<W> {\n\tproxy: Proxied<W>;\n\tdispose(): void;\n\tsetChannel<T extends object>(channel: string, handler: T): void;\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\n}\n\nexport interface IWorkerServer {\n\tsetChannel<T extends object>(channel: string, handler: T): void;\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\n}\n\n/**\n * Main thread side\n */\nexport class SimpleWorkerClient<W extends object> extends Disposable implements IWorkerClient<W> {\n\n\tprivate readonly _worker: IWorker;\n\tprivate readonly _onModuleLoaded: Promise<void>;\n\tprivate readonly _protocol: SimpleWorkerProtocol;\n\tpublic readonly proxy: Proxied<W>;\n\tprivate readonly _localChannels: Map<string, object> = new Map();\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\n\n\tconstructor(\n\t\tworkerFactory: IWorkerFactory,\n\t\tworkerDescriptor: IWorkerDescriptor,\n\t) {\n\t\tsuper();\n\n\t\tthis._worker = this._register(workerFactory.create(\n\t\t\t{\n\t\t\t\tmoduleId: 'vs/base/common/worker/simpleWorker',\n\t\t\t\tesmModuleLocation: workerDescriptor.esmModuleLocation,\n\t\t\t\tlabel: workerDescriptor.label\n\t\t\t},\n\t\t\t(msg: Message) => {\n\t\t\t\tthis._protocol.handleMessage(msg);\n\t\t\t},\n\t\t\t(err: any) => {\n\t\t\t\t// in Firefox, web workers fail lazily :(\n\t\t\t\t// we will reject the proxy\n\t\t\t\tonUnexpectedError(err);\n\t\t\t}\n\t\t));\n\n\t\tthis._protocol = new SimpleWorkerProtocol({\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\n\t\t\t\tthis._worker.postMessage(msg, transfer);\n\t\t\t},\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => {\n\t\t\t\treturn this._handleMessage(channel, method, args);\n\t\t\t},\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => {\n\t\t\t\treturn this._handleEvent(channel, eventName, arg);\n\t\t\t}\n\t\t});\n\t\tthis._protocol.setWorkerId(this._worker.getId());\n\n\t\t// Gather loader configuration\n\t\tlet loaderConfiguration: any = null;\n\n\t\tconst globalRequire: { getConfig?(): object } | undefined = (globalThis as any).require;\n\t\tif (typeof globalRequire !== 'undefined' && typeof globalRequire.getConfig === 'function') {\n\t\t\t// Get the configuration from the Monaco AMD Loader\n\t\t\tloaderConfiguration = globalRequire.getConfig();\n\t\t} else if (typeof (globalThis as any).requirejs !== 'undefined') {\n\t\t\t// Get the configuration from requirejs\n\t\t\tloaderConfiguration = (globalThis as any).requirejs.s.contexts._.config;\n\t\t}\n\n\t\t// Send initialize message\n\t\tthis._onModuleLoaded = this._protocol.sendMessage(DEFAULT_CHANNEL, INITIALIZE, [\n\t\t\tthis._worker.getId(),\n\t\t\tJSON.parse(JSON.stringify(loaderConfiguration)),\n\t\t\tworkerDescriptor.moduleId,\n\t\t]);\n\n\t\tthis.proxy = this._protocol.createProxyToRemoteChannel(DEFAULT_CHANNEL, async () => { await this._onModuleLoaded; });\n\t\tthis._onModuleLoaded.catch((e) => {\n\t\t\tthis._onError('Worker failed to load ' + workerDescriptor.moduleId, e);\n\t\t});\n\t}\n\n\tprivate _handleMessage(channelName: string, method: string, args: any[]): Promise<any> {\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\n\t\tif (!channel) {\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channelName} on main thread`));\n\t\t}\n\t\tif (typeof (channel as any)[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on main thread channel ${channelName}`));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve((channel as any)[method].apply(channel, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _handleEvent(channelName: string, eventName: string, arg: any): Event<any> {\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error(`Missing channel ${channelName} on main thread`);\n\t\t}\n\t\tif (propertyIsDynamicEvent(eventName)) {\n\t\t\tconst event = (channel as any)[eventName].call(channel, arg);\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on main thread channel ${channelName}.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tif (propertyIsEvent(eventName)) {\n\t\t\tconst event = (channel as any)[eventName];\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing event ${eventName} on main thread channel ${channelName}.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tthrow new Error(`Malformed event name ${eventName}`);\n\t}\n\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\n\t\tthis._localChannels.set(channel, handler);\n\t}\n\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\n\t\tif (!this._remoteChannels.has(channel)) {\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel, async () => { await this._onModuleLoaded; });\n\t\t\tthis._remoteChannels.set(channel, inst);\n\t\t}\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\n\t}\n\n\tprivate _onError(message: string, error?: any): void {\n\t\tconsole.error(message);\n\t\tconsole.info(error);\n\t}\n}\n\nfunction propertyIsEvent(name: string): boolean {\n\t// Assume a property is an event if it has a form of \"onSomething\"\n\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n}\n\nfunction propertyIsDynamicEvent(name: string): boolean {\n\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\n}\n\nexport interface IRequestHandler {\n\t_requestHandlerBrand: any;\n\t[prop: string]: any;\n}\n\nexport interface IRequestHandlerFactory {\n\t(workerServer: IWorkerServer): IRequestHandler;\n}\n\n/**\n * Worker side\n */\nexport class SimpleWorkerServer implements IWorkerServer {\n\n\tprivate _requestHandlerFactory: IRequestHandlerFactory | null;\n\tprivate _requestHandler: IRequestHandler | null;\n\tprivate _protocol: SimpleWorkerProtocol;\n\tprivate readonly _localChannels: Map<string, object> = new Map();\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\n\n\tconstructor(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void, requestHandlerFactory: IRequestHandlerFactory | null) {\n\t\tthis._requestHandlerFactory = requestHandlerFactory;\n\t\tthis._requestHandler = null;\n\t\tthis._protocol = new SimpleWorkerProtocol({\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\n\t\t\t\tpostMessage(msg, transfer);\n\t\t\t},\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => this._handleMessage(channel, method, args),\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => this._handleEvent(channel, eventName, arg)\n\t\t});\n\t}\n\n\tpublic onmessage(msg: any): void {\n\t\tthis._protocol.handleMessage(msg);\n\t}\n\n\tprivate _handleMessage(channel: string, method: string, args: any[]): Promise<any> {\n\t\tif (channel === DEFAULT_CHANNEL && method === INITIALIZE) {\n\t\t\treturn this.initialize(<number>args[0], <any>args[1], <string>args[2]);\n\t\t}\n\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\n\t\tif (!requestHandler) {\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channel} on worker thread`));\n\t\t}\n\t\tif (typeof (requestHandler as any)[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve((requestHandler as any)[method].apply(requestHandler, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _handleEvent(channel: string, eventName: string, arg: any): Event<any> {\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\n\t\tif (!requestHandler) {\n\t\t\tthrow new Error(`Missing channel ${channel} on worker thread`);\n\t\t}\n\t\tif (propertyIsDynamicEvent(eventName)) {\n\t\t\tconst event = (requestHandler as any)[eventName].call(requestHandler, arg);\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on request handler.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tif (propertyIsEvent(eventName)) {\n\t\t\tconst event = (requestHandler as any)[eventName];\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing event ${eventName} on request handler.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tthrow new Error(`Malformed event name ${eventName}`);\n\t}\n\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\n\t\tthis._localChannels.set(channel, handler);\n\t}\n\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\n\t\tif (!this._remoteChannels.has(channel)) {\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel);\n\t\t\tthis._remoteChannels.set(channel, inst);\n\t\t}\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\n\t}\n\n\tprivate async initialize(workerId: number, loaderConfig: any, moduleId: string): Promise<void> {\n\t\tthis._protocol.setWorkerId(workerId);\n\n\t\tif (this._requestHandlerFactory) {\n\t\t\t// static request handler\n\t\t\tthis._requestHandler = this._requestHandlerFactory(this);\n\t\t\treturn;\n\t\t}\n\n\t\tif (loaderConfig) {\n\t\t\t// Remove 'baseUrl', handling it is beyond scope for now\n\t\t\tif (typeof loaderConfig.baseUrl !== 'undefined') {\n\t\t\t\tdelete loaderConfig['baseUrl'];\n\t\t\t}\n\t\t\tif (typeof loaderConfig.paths !== 'undefined') {\n\t\t\t\tif (typeof loaderConfig.paths.vs !== 'undefined') {\n\t\t\t\t\tdelete loaderConfig.paths['vs'];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {\n\t\t\t\t// don't use, it has been destroyed during serialize\n\t\t\t\tdelete loaderConfig['trustedTypesPolicy'];\n\t\t\t}\n\n\t\t\t// Since this is in a web worker, enable catching errors\n\t\t\tloaderConfig.catchError = true;\n\t\t\t(globalThis as any).require.config(loaderConfig);\n\t\t}\n\n\t\tconst url = FileAccess.asBrowserUri(`${moduleId}.js` as AppResourcePath).toString(true);\n\t\treturn import(\n\t\t\t/* webpackInclude: /\\.js$/ */\n\t\t\t`${url}`\n\t\t).then((module: { create: IRequestHandlerFactory }) => {\n\t\t\tthis._requestHandler = module.create(this);\n\n\t\t\tif (!this._requestHandler) {\n\t\t\t\tthrow new Error(`No RequestHandler!`);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * Defines the worker entry point. Must be exported and named `create`.\n * @skipMangle\n */\nexport function create(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void): SimpleWorkerServer {\n\treturn new SimpleWorkerServer(postMessage, null);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../charCode.js';\nimport { onUnexpectedError, transformErrorForSerialization } from '../errors.js';\nimport { Emitter, Event } from '../event.js';\nimport { Disposable, IDisposable } from '../lifecycle.js';\nimport { AppResourcePath, FileAccess } from '../network.js';\nimport { isWeb } from '../platform.js';\nimport * as strings from '../strings.js';\nimport { URI } from '../uri.js';\n\nconst DEFAULT_CHANNEL = 'default';\nconst INITIALIZE = '$initialize';\n\nexport interface IWorker extends IDisposable {\n\tgetId(): number;\n\tpostMessage(message: Message, transfer: ArrayBuffer[]): void;\n}\n\nexport interface IWorkerCallback {\n\t(message: Message): void;\n}\n\nexport interface IWorkerFactory {\n\tcreate(modules: IWorkerDescriptor, callback: IWorkerCallback, onErrorCallback: (err: any) => void): IWorker;\n}\n\nexport interface IWorkerDescriptor {\n\treadonly moduleId: string;\n\treadonly esmModuleLocation: URI | undefined;\n\treadonly label: string | undefined;\n}\n\nlet webWorkerWarningLogged = false;\nexport function logOnceWebWorkerWarning(err: any): void {\n\tif (!isWeb) {\n\t\t// running tests\n\t\treturn;\n\t}\n\tif (!webWorkerWarningLogged) {\n\t\twebWorkerWarningLogged = true;\n\t\tconsole.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\n\t}\n\tconsole.warn(err.message);\n}\n\nconst enum MessageType {\n\tRequest,\n\tReply,\n\tSubscribeEvent,\n\tEvent,\n\tUnsubscribeEvent\n}\nclass RequestMessage {\n\tpublic readonly type = MessageType.Request;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly channel: string,\n\t\tpublic readonly method: string,\n\t\tpublic readonly args: any[]\n\t) { }\n}\nclass ReplyMessage {\n\tpublic readonly type = MessageType.Reply;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly seq: string,\n\t\tpublic readonly res: any,\n\t\tpublic readonly err: any\n\t) { }\n}\nclass SubscribeEventMessage {\n\tpublic readonly type = MessageType.SubscribeEvent;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly channel: string,\n\t\tpublic readonly eventName: string,\n\t\tpublic readonly arg: any\n\t) { }\n}\nclass EventMessage {\n\tpublic readonly type = MessageType.Event;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly event: any\n\t) { }\n}\nclass UnsubscribeEventMessage {\n\tpublic readonly type = MessageType.UnsubscribeEvent;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string\n\t) { }\n}\ntype Message = RequestMessage | ReplyMessage | SubscribeEventMessage | EventMessage | UnsubscribeEventMessage;\n\ninterface IMessageReply {\n\tresolve: (value?: any) => void;\n\treject: (error?: any) => void;\n}\n\ninterface IMessageHandler {\n\tsendMessage(msg: any, transfer?: ArrayBuffer[]): void;\n\thandleMessage(channel: string, method: string, args: any[]): Promise<any>;\n\thandleEvent(channel: string, eventName: string, arg: any): Event<any>;\n}\n\nclass SimpleWorkerProtocol {\n\n\tprivate _workerId: number;\n\tprivate _lastSentReq: number;\n\tprivate _pendingReplies: { [req: string]: IMessageReply };\n\tprivate _pendingEmitters: Map<string, Emitter<any>>;\n\tprivate _pendingEvents: Map<string, IDisposable>;\n\tprivate _handler: IMessageHandler;\n\n\tconstructor(handler: IMessageHandler) {\n\t\tthis._workerId = -1;\n\t\tthis._handler = handler;\n\t\tthis._lastSentReq = 0;\n\t\tthis._pendingReplies = Object.create(null);\n\t\tthis._pendingEmitters = new Map<string, Emitter<any>>();\n\t\tthis._pendingEvents = new Map<string, IDisposable>();\n\t}\n\n\tpublic setWorkerId(workerId: number): void {\n\t\tthis._workerId = workerId;\n\t}\n\n\tpublic sendMessage(channel: string, method: string, args: any[]): Promise<any> {\n\t\tconst req = String(++this._lastSentReq);\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\tthis._pendingReplies[req] = {\n\t\t\t\tresolve: resolve,\n\t\t\t\treject: reject\n\t\t\t};\n\t\t\tthis._send(new RequestMessage(this._workerId, req, channel, method, args));\n\t\t});\n\t}\n\n\tpublic listen(channel: string, eventName: string, arg: any): Event<any> {\n\t\tlet req: string | null = null;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\treq = String(++this._lastSentReq);\n\t\t\t\tthis._pendingEmitters.set(req, emitter);\n\t\t\t\tthis._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis._pendingEmitters.delete(req!);\n\t\t\t\tthis._send(new UnsubscribeEventMessage(this._workerId, req!));\n\t\t\t\treq = null;\n\t\t\t}\n\t\t});\n\t\treturn emitter.event;\n\t}\n\n\tpublic handleMessage(message: Message): void {\n\t\tif (!message || !message.vsWorker) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._workerId !== -1 && message.vsWorker !== this._workerId) {\n\t\t\treturn;\n\t\t}\n\t\tthis._handleMessage(message);\n\t}\n\n\tpublic createProxyToRemoteChannel<T extends object>(channel: string, sendMessageBarrier?: () => Promise<void>): T {\n\t\tconst handler = {\n\t\t\tget: (target: any, name: PropertyKey) => {\n\t\t\t\tif (typeof name === 'string' && !target[name]) {\n\t\t\t\t\tif (propertyIsDynamicEvent(name)) { // onDynamic...\n\t\t\t\t\t\ttarget[name] = (arg: any): Event<any> => {\n\t\t\t\t\t\t\treturn this.listen(channel, name, arg);\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (propertyIsEvent(name)) { // on...\n\t\t\t\t\t\ttarget[name] = this.listen(channel, name, undefined);\n\t\t\t\t\t} else if (name.charCodeAt(0) === CharCode.DollarSign) { // $...\n\t\t\t\t\t\ttarget[name] = async (...myArgs: any[]) => {\n\t\t\t\t\t\t\tawait sendMessageBarrier?.();\n\t\t\t\t\t\t\treturn this.sendMessage(channel, name, myArgs);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target[name];\n\t\t\t}\n\t\t};\n\t\treturn new Proxy(Object.create(null), handler);\n\t}\n\n\tprivate _handleMessage(msg: Message): void {\n\t\tswitch (msg.type) {\n\t\t\tcase MessageType.Reply:\n\t\t\t\treturn this._handleReplyMessage(msg);\n\t\t\tcase MessageType.Request:\n\t\t\t\treturn this._handleRequestMessage(msg);\n\t\t\tcase MessageType.SubscribeEvent:\n\t\t\t\treturn this._handleSubscribeEventMessage(msg);\n\t\t\tcase MessageType.Event:\n\t\t\t\treturn this._handleEventMessage(msg);\n\t\t\tcase MessageType.UnsubscribeEvent:\n\t\t\t\treturn this._handleUnsubscribeEventMessage(msg);\n\t\t}\n\t}\n\n\tprivate _handleReplyMessage(replyMessage: ReplyMessage): void {\n\t\tif (!this._pendingReplies[replyMessage.seq]) {\n\t\t\tconsole.warn('Got reply to unknown seq');\n\t\t\treturn;\n\t\t}\n\n\t\tconst reply = this._pendingReplies[replyMessage.seq];\n\t\tdelete this._pendingReplies[replyMessage.seq];\n\n\t\tif (replyMessage.err) {\n\t\t\tlet err = replyMessage.err;\n\t\t\tif (replyMessage.err.$isError) {\n\t\t\t\terr = new Error();\n\t\t\t\terr.name = replyMessage.err.name;\n\t\t\t\terr.message = replyMessage.err.message;\n\t\t\t\terr.stack = replyMessage.err.stack;\n\t\t\t}\n\t\t\treply.reject(err);\n\t\t\treturn;\n\t\t}\n\n\t\treply.resolve(replyMessage.res);\n\t}\n\n\tprivate _handleRequestMessage(requestMessage: RequestMessage): void {\n\t\tconst req = requestMessage.req;\n\t\tconst result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);\n\t\tresult.then((r) => {\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, r, undefined));\n\t\t}, (e) => {\n\t\t\tif (e.detail instanceof Error) {\n\t\t\t\t// Loading errors have a detail property that points to the actual error\n\t\t\t\te.detail = transformErrorForSerialization(e.detail);\n\t\t\t}\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e)));\n\t\t});\n\t}\n\n\tprivate _handleSubscribeEventMessage(msg: SubscribeEventMessage): void {\n\t\tconst req = msg.req;\n\t\tconst disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {\n\t\t\tthis._send(new EventMessage(this._workerId, req, event));\n\t\t});\n\t\tthis._pendingEvents.set(req, disposable);\n\t}\n\n\tprivate _handleEventMessage(msg: EventMessage): void {\n\t\tif (!this._pendingEmitters.has(msg.req)) {\n\t\t\tconsole.warn('Got event for unknown req');\n\t\t\treturn;\n\t\t}\n\t\tthis._pendingEmitters.get(msg.req)!.fire(msg.event);\n\t}\n\n\tprivate _handleUnsubscribeEventMessage(msg: UnsubscribeEventMessage): void {\n\t\tif (!this._pendingEvents.has(msg.req)) {\n\t\t\tconsole.warn('Got unsubscribe for unknown req');\n\t\t\treturn;\n\t\t}\n\t\tthis._pendingEvents.get(msg.req)!.dispose();\n\t\tthis._pendingEvents.delete(msg.req);\n\t}\n\n\tprivate _send(msg: Message): void {\n\t\tconst transfer: ArrayBuffer[] = [];\n\t\tif (msg.type === MessageType.Request) {\n\t\t\tfor (let i = 0; i < msg.args.length; i++) {\n\t\t\t\tif (msg.args[i] instanceof ArrayBuffer) {\n\t\t\t\t\ttransfer.push(msg.args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (msg.type === MessageType.Reply) {\n\t\t\tif (msg.res instanceof ArrayBuffer) {\n\t\t\t\ttransfer.push(msg.res);\n\t\t\t}\n\t\t}\n\t\tthis._handler.sendMessage(msg, transfer);\n\t}\n}\n\ntype ProxiedMethodName = (`$${string}` | `on${string}`);\n\nexport type Proxied<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R\n\t? (\n\t\tK extends ProxiedMethodName\n\t\t? (...args: A) => Promise<Awaited<R>>\n\t\t: never\n\t)\n\t: never\n};\n\nexport interface IWorkerClient<W> {\n\tproxy: Proxied<W>;\n\tdispose(): void;\n\tsetChannel<T extends object>(channel: string, handler: T): void;\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\n}\n\nexport interface IWorkerServer {\n\tsetChannel<T extends object>(channel: string, handler: T): void;\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\n}\n\n/**\n * Main thread side\n */\nexport class SimpleWorkerClient<W extends object> extends Disposable implements IWorkerClient<W> {\n\n\tprivate readonly _worker: IWorker;\n\tprivate readonly _onModuleLoaded: Promise<void>;\n\tprivate readonly _protocol: SimpleWorkerProtocol;\n\tpublic readonly proxy: Proxied<W>;\n\tprivate readonly _localChannels: Map<string, object> = new Map();\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\n\n\tconstructor(\n\t\tworkerFactory: IWorkerFactory,\n\t\tworkerDescriptor: IWorkerDescriptor,\n\t) {\n\t\tsuper();\n\n\t\tthis._worker = this._register(workerFactory.create(\n\t\t\t{\n\t\t\t\tmoduleId: 'vs/base/common/worker/simpleWorker',\n\t\t\t\tesmModuleLocation: workerDescriptor.esmModuleLocation,\n\t\t\t\tlabel: workerDescriptor.label\n\t\t\t},\n\t\t\t(msg: Message) => {\n\t\t\t\tthis._protocol.handleMessage(msg);\n\t\t\t},\n\t\t\t(err: any) => {\n\t\t\t\t// in Firefox, web workers fail lazily :(\n\t\t\t\t// we will reject the proxy\n\t\t\t\tonUnexpectedError(err);\n\t\t\t}\n\t\t));\n\n\t\tthis._protocol = new SimpleWorkerProtocol({\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\n\t\t\t\tthis._worker.postMessage(msg, transfer);\n\t\t\t},\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => {\n\t\t\t\treturn this._handleMessage(channel, method, args);\n\t\t\t},\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => {\n\t\t\t\treturn this._handleEvent(channel, eventName, arg);\n\t\t\t}\n\t\t});\n\t\tthis._protocol.setWorkerId(this._worker.getId());\n\n\t\t// Gather loader configuration\n\t\tlet loaderConfiguration: any = null;\n\n\t\tconst globalRequire: { getConfig?(): object } | undefined = (globalThis as any).require;\n\t\tif (typeof globalRequire !== 'undefined' && typeof globalRequire.getConfig === 'function') {\n\t\t\t// Get the configuration from the Monaco AMD Loader\n\t\t\tloaderConfiguration = globalRequire.getConfig();\n\t\t} else if (typeof (globalThis as any).requirejs !== 'undefined') {\n\t\t\t// Get the configuration from requirejs\n\t\t\tloaderConfiguration = (globalThis as any).requirejs.s.contexts._.config;\n\t\t}\n\n\t\t// Send initialize message\n\t\tthis._onModuleLoaded = this._protocol.sendMessage(DEFAULT_CHANNEL, INITIALIZE, [\n\t\t\tthis._worker.getId(),\n\t\t\tJSON.parse(JSON.stringify(loaderConfiguration)),\n\t\t\tworkerDescriptor.moduleId,\n\t\t]);\n\n\t\tthis.proxy = this._protocol.createProxyToRemoteChannel(DEFAULT_CHANNEL, async () => { await this._onModuleLoaded; });\n\t\tthis._onModuleLoaded.catch((e) => {\n\t\t\tthis._onError('Worker failed to load ' + workerDescriptor.moduleId, e);\n\t\t});\n\t}\n\n\tprivate _handleMessage(channelName: string, method: string, args: any[]): Promise<any> {\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\n\t\tif (!channel) {\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channelName} on main thread`));\n\t\t}\n\t\tif (typeof (channel as any)[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on main thread channel ${channelName}`));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve((channel as any)[method].apply(channel, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _handleEvent(channelName: string, eventName: string, arg: any): Event<any> {\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error(`Missing channel ${channelName} on main thread`);\n\t\t}\n\t\tif (propertyIsDynamicEvent(eventName)) {\n\t\t\tconst event = (channel as any)[eventName].call(channel, arg);\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on main thread channel ${channelName}.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tif (propertyIsEvent(eventName)) {\n\t\t\tconst event = (channel as any)[eventName];\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing event ${eventName} on main thread channel ${channelName}.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tthrow new Error(`Malformed event name ${eventName}`);\n\t}\n\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\n\t\tthis._localChannels.set(channel, handler);\n\t}\n\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\n\t\tif (!this._remoteChannels.has(channel)) {\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel, async () => { await this._onModuleLoaded; });\n\t\t\tthis._remoteChannels.set(channel, inst);\n\t\t}\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\n\t}\n\n\tprivate _onError(message: string, error?: any): void {\n\t\tconsole.error(message);\n\t\tconsole.info(error);\n\t}\n}\n\nfunction propertyIsEvent(name: string): boolean {\n\t// Assume a property is an event if it has a form of \"onSomething\"\n\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n}\n\nfunction propertyIsDynamicEvent(name: string): boolean {\n\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\n}\n\nexport interface IRequestHandler {\n\t_requestHandlerBrand: any;\n\t[prop: string]: any;\n}\n\nexport interface IRequestHandlerFactory {\n\t(workerServer: IWorkerServer): IRequestHandler;\n}\n\n/**\n * Worker side\n */\nexport class SimpleWorkerServer implements IWorkerServer {\n\n\tprivate _requestHandlerFactory: IRequestHandlerFactory | null;\n\tprivate _requestHandler: IRequestHandler | null;\n\tprivate _protocol: SimpleWorkerProtocol;\n\tprivate readonly _localChannels: Map<string, object> = new Map();\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\n\n\tconstructor(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void, requestHandlerFactory: IRequestHandlerFactory | null) {\n\t\tthis._requestHandlerFactory = requestHandlerFactory;\n\t\tthis._requestHandler = null;\n\t\tthis._protocol = new SimpleWorkerProtocol({\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\n\t\t\t\tpostMessage(msg, transfer);\n\t\t\t},\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => this._handleMessage(channel, method, args),\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => this._handleEvent(channel, eventName, arg)\n\t\t});\n\t}\n\n\tpublic onmessage(msg: any): void {\n\t\tthis._protocol.handleMessage(msg);\n\t}\n\n\tprivate _handleMessage(channel: string, method: string, args: any[]): Promise<any> {\n\t\tif (channel === DEFAULT_CHANNEL && method === INITIALIZE) {\n\t\t\treturn this.initialize(<number>args[0], <any>args[1], <string>args[2]);\n\t\t}\n\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\n\t\tif (!requestHandler) {\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channel} on worker thread`));\n\t\t}\n\t\tif (typeof (requestHandler as any)[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve((requestHandler as any)[method].apply(requestHandler, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _handleEvent(channel: string, eventName: string, arg: any): Event<any> {\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel));\n\t\tif (!requestHandler) {\n\t\t\tthrow new Error(`Missing channel ${channel} on worker thread`);\n\t\t}\n\t\tif (propertyIsDynamicEvent(eventName)) {\n\t\t\tconst event = (requestHandler as any)[eventName].call(requestHandler, arg);\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on request handler.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tif (propertyIsEvent(eventName)) {\n\t\t\tconst event = (requestHandler as any)[eventName];\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing event ${eventName} on request handler.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tthrow new Error(`Malformed event name ${eventName}`);\n\t}\n\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\n\t\tthis._localChannels.set(channel, handler);\n\t}\n\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\n\t\tif (!this._remoteChannels.has(channel)) {\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel);\n\t\t\tthis._remoteChannels.set(channel, inst);\n\t\t}\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\n\t}\n\n\tprivate async initialize(workerId: number, loaderConfig: any, moduleId: string): Promise<void> {\n\t\tthis._protocol.setWorkerId(workerId);\n\n\t\tif (this._requestHandlerFactory) {\n\t\t\t// static request handler\n\t\t\tthis._requestHandler = this._requestHandlerFactory(this);\n\t\t\treturn;\n\t\t}\n\n\t\tif (loaderConfig) {\n\t\t\t// Remove 'baseUrl', handling it is beyond scope for now\n\t\t\tif (typeof loaderConfig.baseUrl !== 'undefined') {\n\t\t\t\tdelete loaderConfig['baseUrl'];\n\t\t\t}\n\t\t\tif (typeof loaderConfig.paths !== 'undefined') {\n\t\t\t\tif (typeof loaderConfig.paths.vs !== 'undefined') {\n\t\t\t\t\tdelete loaderConfig.paths['vs'];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {\n\t\t\t\t// don't use, it has been destroyed during serialize\n\t\t\t\tdelete loaderConfig['trustedTypesPolicy'];\n\t\t\t}\n\n\t\t\t// Since this is in a web worker, enable catching errors\n\t\t\tloaderConfig.catchError = true;\n\t\t\t(globalThis as any).require.config(loaderConfig);\n\t\t}\n\n\t\tconst url = FileAccess.asBrowserUri(`${moduleId}.js` as AppResourcePath).toString(true);\n\t\treturn import(\n\t\t\t/* webpackInclude: /\\.js$/ */\n\t\t\t`${url}`\n\t\t).then((module: { create: IRequestHandlerFactory }) => {\n\t\t\tthis._requestHandler = module.create(this);\n\n\t\t\tif (!this._requestHandler) {\n\t\t\t\tthrow new Error(`No RequestHandler!`);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * Defines the worker entry point. Must be exported and named `create`.\n * @skipMangle\n */\nexport function create(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void): SimpleWorkerServer {\n\treturn new SimpleWorkerServer(postMessage, null);\n}\n"],"mappings":"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","names":["MessageType","require"],"file":"workerMain.js"}