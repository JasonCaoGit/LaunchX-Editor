{"version":3,"sources":["file:///Users/kw/github/monaco-editor-core/out-editor-esm/vs/base/common/observableInternal/utils.ts","vs/base/common/observableInternal/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourceRoot":"file:///Users/kw/github/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { autorunWithStoreHandleChanges } from './autorun.js';\nimport { BaseObservable, ConvenientObservable, IObservable, IObservableWithChange, IObserver, IReader, ITransaction, _setKeepObserved, _setRecomputeInitiallyAndOnChange, subtransaction, transaction } from './base.js';\nimport { DebugNameData, DebugOwner, IDebugNameData } from './debugName.js';\nimport { DisposableStore, EqualityComparer, Event, IDisposable, IValueWithChangeEvent, strictEquals, toDisposable } from './commonFacade/deps.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\n\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\n\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\towner: DebugOwner,\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent(...args:\n\t[owner: DebugOwner, event: Event<any>, getValue: (args: any | undefined) => any]\n\t| [event: Event<any>, getValue: (args: any | undefined) => any]\n): IObservable<any> {\n\tlet owner;\n\tlet event;\n\tlet getValue;\n\tif (args.length === 3) {\n\t\t[owner, event, getValue] = args;\n\t} else {\n\t\t[event, getValue] = args;\n\t}\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(owner, undefined, getValue),\n\t\tevent,\n\t\tgetValue,\n\t\t() => FromEventObservable.globalTransaction,\n\t\tstrictEquals\n\t);\n}\n\nexport function observableFromEventOpts<T, TArgs = unknown>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t},\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T> {\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue),\n\t\tevent,\n\t\tgetValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals\n\t);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate value: T | undefined;\n\tprivate hasValue = false;\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T,\n\t\tprivate readonly _getTransaction: () => ITransaction | undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn this._debugNameData.getDebugName(this);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this.value;\n\n\t\tconst didChange = !this.hasValue || !(this._equalityComparator(oldValue!, newValue));\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis.value = newValue;\n\n\t\t\tif (this.hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tthis._getTransaction(),\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\n\t\t\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t\tthis.hasValue = false;\n\t\tthis.value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this.subscription) {\n\t\t\tif (!this.hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this.value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\tconst value = this._getValue(undefined);\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(tx: ITransaction, fn: () => void): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function observableSignalFromEvent(\n\towner: DebugOwner | string,\n\tevent: Event<any>\n): IObservable<void> {\n\treturn new FromEventObservableSignal(typeof owner === 'string' ? owner : new DebugNameData(owner, undefined, undefined), event);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tpublic readonly debugName: string;\n\tconstructor(\n\t\tdebugNameDataOrName: DebugNameData | string,\n\t\tprivate readonly event: Event<any>,\n\t) {\n\t\tsuper();\n\t\tthis.debugName = typeof debugNameDataOrName === 'string'\n\t\t\t? debugNameDataOrName\n\t\t\t: debugNameDataOrName.getDebugName(this) ?? 'Observable Signal From Event';\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservableWithChange<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tpublic override toString(): string {\n\t\treturn this.debugName;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner?: object,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this.observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\tif (handleValue) {\n\t\thandleValue(observable.get());\n\t} else {\n\t\tobservable.reportChanges();\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T>): void {\n\t\tthis._counter--;\n\t\tif (this._counter === 0 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(owner: DebugOwner, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T>\n\t& { clearCache(transaction: ITransaction): void; setCache(newValue: T | undefined, tx: ITransaction | undefined): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst onChange = observableSignal('derivedObservableWithWritableCache');\n\tconst observable = derived(owner, reader => {\n\t\tonChange.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (tx: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tonChange.trigger(tx);\n\t\t},\n\t\tsetCache: (newValue: T | undefined, tx: ITransaction | undefined) => {\n\t\t\tlastValue = newValue;\n\t\t\tonChange.trigger(tx);\n\t\t}\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: DebugOwner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n\nexport class ValueWithChangeEventFromObservable<T> implements IValueWithChangeEvent<T> {\n\tconstructor(public readonly observable: IObservable<T>) {\n\t}\n\n\tget onDidChange(): Event<void> {\n\t\treturn Event.fromObservableLight(this.observable);\n\t}\n\n\tget value(): T {\n\t\treturn this.observable.get();\n\t}\n}\n\nexport function observableFromValueWithChangeEvent<T>(owner: DebugOwner, value: IValueWithChangeEvent<T>): IObservable<T> {\n\tif (value instanceof ValueWithChangeEventFromObservable) {\n\t\treturn value.observable;\n\t}\n\treturn observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined<T>(owner: DebugOwner, fn: (reader: IReader) => T): IObservable<T | undefined> {\n\treturn derivedObservableWithCache<T | undefined>(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n\ntype RemoveUndefined<T> = T extends undefined ? never : T;\n\nexport function runOnChange<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: undefined | T, deltas: RemoveUndefined<TChange>[]) => void): IDisposable {\n\tlet _previousValue: T | undefined;\n\treturn autorunWithStoreHandleChanges({\n\t\tcreateEmptyChangeSummary: () => ({ deltas: [] as RemoveUndefined<TChange>[], didChange: false }),\n\t\thandleChange: (context, changeSummary) => {\n\t\t\tif (context.didChange(observable)) {\n\t\t\t\tconst e = context.change;\n\t\t\t\tif (e !== undefined) {\n\t\t\t\t\tchangeSummary.deltas.push(e as RemoveUndefined<TChange>);\n\t\t\t\t}\n\t\t\t\tchangeSummary.didChange = true;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t}, (reader, changeSummary) => {\n\t\tconst value = observable.read(reader);\n\t\tconst previousValue = _previousValue;\n\t\tif (changeSummary.didChange) {\n\t\t\t_previousValue = value;\n\t\t\tcb(value, previousValue, changeSummary.deltas);\n\t\t}\n\t});\n}\n\nexport function runOnChangeWithStore<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: undefined | T, deltas: RemoveUndefined<TChange>[], store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = runOnChange(observable, (value, previousValue: undefined | T, deltas) => {\n\t\tstore.clear();\n\t\tcb(value, previousValue, deltas, store);\n\t});\n\treturn {\n\t\tdispose() {\n\t\t\tdisposable.dispose();\n\t\t\tstore.dispose();\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { autorunWithStoreHandleChanges } from './autorun.js';\nimport { BaseObservable, ConvenientObservable, IObservable, IObservableWithChange, IObserver, IReader, ITransaction, _setKeepObserved, _setRecomputeInitiallyAndOnChange, subtransaction, transaction } from './base.js';\nimport { DebugNameData, DebugOwner, IDebugNameData } from './debugName.js';\nimport { DisposableStore, EqualityComparer, Event, IDisposable, IValueWithChangeEvent, strictEquals, toDisposable } from './commonFacade/deps.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\n\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\n\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\towner: DebugOwner,\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent(...args:\n\t[owner: DebugOwner, event: Event<any>, getValue: (args: any | undefined) => any]\n\t| [event: Event<any>, getValue: (args: any | undefined) => any]\n): IObservable<any> {\n\tlet owner;\n\tlet event;\n\tlet getValue;\n\tif (args.length === 3) {\n\t\t[owner, event, getValue] = args;\n\t} else {\n\t\t[event, getValue] = args;\n\t}\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(owner, undefined, getValue),\n\t\tevent,\n\t\tgetValue,\n\t\t() => FromEventObservable.globalTransaction,\n\t\tstrictEquals\n\t);\n}\n\nexport function observableFromEventOpts<T, TArgs = unknown>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t},\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T> {\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue),\n\t\tevent,\n\t\tgetValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals\n\t);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate value: T | undefined;\n\tprivate hasValue = false;\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T,\n\t\tprivate readonly _getTransaction: () => ITransaction | undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn this._debugNameData.getDebugName(this);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this.value;\n\n\t\tconst didChange = !this.hasValue || !(this._equalityComparator(oldValue!, newValue));\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis.value = newValue;\n\n\t\t\tif (this.hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tthis._getTransaction(),\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\n\t\t\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t\tthis.hasValue = false;\n\t\tthis.value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this.subscription) {\n\t\t\tif (!this.hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this.value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\tconst value = this._getValue(undefined);\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(tx: ITransaction, fn: () => void): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function observableSignalFromEvent(\n\towner: DebugOwner | string,\n\tevent: Event<any>\n): IObservable<void> {\n\treturn new FromEventObservableSignal(typeof owner === 'string' ? owner : new DebugNameData(owner, undefined, undefined), event);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tpublic readonly debugName: string;\n\tconstructor(\n\t\tdebugNameDataOrName: DebugNameData | string,\n\t\tprivate readonly event: Event<any>,\n\t) {\n\t\tsuper();\n\t\tthis.debugName = typeof debugNameDataOrName === 'string'\n\t\t\t? debugNameDataOrName\n\t\t\t: debugNameDataOrName.getDebugName(this) ?? 'Observable Signal From Event';\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservableWithChange<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tpublic override toString(): string {\n\t\treturn this.debugName;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner?: object,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this.observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\tif (handleValue) {\n\t\thandleValue(observable.get());\n\t} else {\n\t\tobservable.reportChanges();\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T>): void {\n\t\tthis._counter--;\n\t\tif (this._counter === 0 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(owner: DebugOwner, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T>\n\t& { clearCache(transaction: ITransaction): void; setCache(newValue: T | undefined, tx: ITransaction | undefined): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst onChange = observableSignal('derivedObservableWithWritableCache');\n\tconst observable = derived(owner, reader => {\n\t\tonChange.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (tx: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tonChange.trigger(tx);\n\t\t},\n\t\tsetCache: (newValue: T | undefined, tx: ITransaction | undefined) => {\n\t\t\tlastValue = newValue;\n\t\t\tonChange.trigger(tx);\n\t\t}\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: DebugOwner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n\nexport class ValueWithChangeEventFromObservable<T> implements IValueWithChangeEvent<T> {\n\tconstructor(public readonly observable: IObservable<T>) {\n\t}\n\n\tget onDidChange(): Event<void> {\n\t\treturn Event.fromObservableLight(this.observable);\n\t}\n\n\tget value(): T {\n\t\treturn this.observable.get();\n\t}\n}\n\nexport function observableFromValueWithChangeEvent<T>(owner: DebugOwner, value: IValueWithChangeEvent<T>): IObservable<T> {\n\tif (value instanceof ValueWithChangeEventFromObservable) {\n\t\treturn value.observable;\n\t}\n\treturn observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined<T>(owner: DebugOwner, fn: (reader: IReader) => T): IObservable<T | undefined> {\n\treturn derivedObservableWithCache<T | undefined>(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n\ntype RemoveUndefined<T> = T extends undefined ? never : T;\n\nexport function runOnChange<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: undefined | T, deltas: RemoveUndefined<TChange>[]) => void): IDisposable {\n\tlet _previousValue: T | undefined;\n\treturn autorunWithStoreHandleChanges({\n\t\tcreateEmptyChangeSummary: () => ({ deltas: [] as RemoveUndefined<TChange>[], didChange: false }),\n\t\thandleChange: (context, changeSummary) => {\n\t\t\tif (context.didChange(observable)) {\n\t\t\t\tconst e = context.change;\n\t\t\t\tif (e !== undefined) {\n\t\t\t\t\tchangeSummary.deltas.push(e as RemoveUndefined<TChange>);\n\t\t\t\t}\n\t\t\t\tchangeSummary.didChange = true;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t}, (reader, changeSummary) => {\n\t\tconst value = observable.read(reader);\n\t\tconst previousValue = _previousValue;\n\t\tif (changeSummary.didChange) {\n\t\t\t_previousValue = value;\n\t\t\tcb(value, previousValue, changeSummary.deltas);\n\t\t}\n\t});\n}\n\nexport function runOnChangeWithStore<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: undefined | T, deltas: RemoveUndefined<TChange>[], store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = runOnChange(observable, (value, previousValue: undefined | T, deltas) => {\n\t\tstore.clear();\n\t\tcb(value, previousValue, deltas, store);\n\t});\n\treturn {\n\t\tdispose() {\n\t\t\tdisposable.dispose();\n\t\t\tstore.dispose();\n\t\t}\n\t};\n}\n"]}