{"version":3,"sources":["file:///Users/kw/github/monaco-editor-core/out-editor-esm/vs/base/common/observableInternal/derived.ts","vs/base/common/observableInternal/derived.ts"],"names":[],"mappings":"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","file":"derived.js","sourceRoot":"file:///Users/kw/github/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BaseObservable, IChangeContext, IObservable, IObservableWithChange, IObserver, IReader, ISettableObservable, ITransaction, _setDerivedOpts } from './base.js';\nimport { DebugNameData, DebugOwner, IDebugNameData } from './debugName.js';\nimport { BugIndicatingError, DisposableStore, EqualityComparer, IDisposable, assertFn, onBugIndicatingError, strictEquals } from './commonFacade/deps.js';\nimport { getLogger } from './logging.js';\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFn?: ((reader: IReader) => T) | undefined): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tstrictEquals\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals\n\t);\n}\n\nexport function derivedWithSetter<T>(owner: DebugOwner | undefined, computeFn: (reader: IReader) => T, setter: (value: T, transaction: ITransaction | undefined) => void): ISettableObservable<T> {\n\treturn new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tsetter,\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: (() => void);\n\t},\n\tcomputeFn: (reader: IReader) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalsFn ?? strictEquals\n\t);\n}\n\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange,\n\t\tundefined,\n\t\toptions.equalityComparer ?? strictEquals\n\t);\n}\n\nexport function derivedWithStore<T>(computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(owner: object, computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(computeFnOrOwner: ((reader: IReader, store: DisposableStore) => T) | object, computeFnOrUndefined?: ((reader: IReader, store: DisposableStore) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: DisposableStore) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tconst store = new DisposableStore();\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tstore.clear();\n\t\t\treturn computeFn(r, store);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => store.dispose(),\n\t\tstrictEquals\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFnOrUndefined?: ((reader: IReader) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet store: DisposableStore | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (!store) {\n\t\t\t\tstore = new DisposableStore();\n\t\t\t} else {\n\t\t\t\tstore.clear();\n\t\t\t}\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => {\n\t\t\tif (store) {\n\t\t\t\tstore.dispose();\n\t\t\t\tstore = undefined;\n\t\t\t}\n\t\t},\n\t\tstrictEquals\n\t);\n}\n\nconst enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any> extends BaseObservable<T, void> implements IReader, IObserver {\n\tprivate state = DerivedState.initial;\n\tprivate value: T | undefined = undefined;\n\tprivate updateCount = 0;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined = undefined;\n\tprivate _isUpdating = false;\n\tprivate _isComputing = false;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleDerivedCreated(this);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis.state = DerivedState.initial;\n\t\tthis.value = undefined;\n\t\tgetLogger()?.handleDerivedCleared(this);\n\t\tfor (const d of this.dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tif (this._isComputing) {\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tif (this.observers.size === 0) {\n\t\t\tlet result;\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\ttry {\n\t\t\t\tthis._isReaderValid = true;\n\t\t\t\tresult = this._computeFn(this, this.createChangeSummary?.()!);\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t}\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this.state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tthis._recomputeIfNeeded();\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this.state !== DerivedState.upToDate);\n\t\t\treturn this.value!;\n\t\t}\n\t}\n\n\tprivate _recomputeIfNeeded() {\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\treturn;\n\t\t}\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tconst hadValue = this.state !== DerivedState.initial;\n\t\tconst oldValue = this.value;\n\t\tthis.state = DerivedState.upToDate;\n\n\t\tlet didChange = false;\n\n\t\tthis._isComputing = false; // TODO@hediet: Set to true and investigate diff editor scrolling issues! (also see test.skip('catches cyclic dependencies')\n\n\t\ttry {\n\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\ttry {\n\t\t\t\tthis._isReaderValid = true;\n\t\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\t\tthis.value = this._computeFn(this, changeSummary);\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\t\to.removeObserver(this);\n\t\t\t\t}\n\t\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t\t}\n\n\t\t\tdidChange = hadValue && !(this._equalityComparator(oldValue!, this.value));\n\n\t\t\tgetLogger()?.handleDerivedRecomputed(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue: this.value,\n\t\t\t\tchange: undefined,\n\t\t\t\tdidChange,\n\t\t\t\thadValue,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonBugIndicatingError(e);\n\t\t}\n\n\t\tthis._isComputing = false;\n\n\t\tif (didChange) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tif (this._isUpdating) {\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tthis.updateCount++;\n\t\tthis._isUpdating = true;\n\t\ttry {\n\t\t\tconst propagateBeginUpdate = this.updateCount === 1;\n\t\t\tif (this.state === DerivedState.upToDate) {\n\t\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propagateBeginUpdate) {\n\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis._isUpdating = false;\n\t\t}\n\t}\n\n\tprivate _removedObserverToCallEndUpdateOn: Set<IObserver> | null = null;\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount--;\n\t\tif (this.updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this.observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t\tif (this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tconst observers = [...this._removedObserverToCallEndUpdateOn];\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = null;\n\t\t\t\tfor (const r of observers) {\n\t\t\t\t\tr.endUpdate(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this.state === DerivedState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tlet shouldReact = false;\n\t\t\ttry {\n\t\t\t\tshouldReact = this._handleChange ? this._handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this.changeSummary!) : true;\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\n\t\t\tconst wasUpToDate = this.state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this.state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis.state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\tprivate _isReaderValid = false;\n\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\tif (!this._isReaderValid) { throw new BugIndicatingError('The reader object cannot be used outside its compute function!'); }\n\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tif (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(observer)) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn.delete(observer);\n\t\t\t} else {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tif (this.observers.has(observer) && this.updateCount > 0) {\n\t\t\tif (!this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = new Set();\n\t\t\t}\n\t\t\tthis._removedObserverToCallEndUpdateOn.add(observer);\n\t\t}\n\t\tsuper.removeObserver(observer);\n\t}\n\n\tpublic override log(): IObservableWithChange<T, void> {\n\t\tif (!getLogger()) {\n\t\t\tsuper.log();\n\t\t\tgetLogger()?.handleDerivedCreated(this);\n\t\t} else {\n\t\t\tsuper.log();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n\nexport class DerivedWithSetter<T, TChangeSummary = any> extends Derived<T, TChangeSummary> implements ISettableObservable<T> {\n\tconstructor(\n\t\tdebugNameData: DebugNameData,\n\t\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tcreateChangeSummary: (() => TChangeSummary) | undefined,\n\t\thandleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\thandleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tequalityComparator: EqualityComparer<T>,\n\t\tpublic readonly set: (value: T, tx: ITransaction | undefined) => void,\n\t) {\n\t\tsuper(\n\t\t\tdebugNameData,\n\t\t\tcomputeFn,\n\t\t\tcreateChangeSummary,\n\t\t\thandleChange,\n\t\t\thandleLastObserverRemoved,\n\t\t\tequalityComparator,\n\t\t);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BaseObservable, IChangeContext, IObservable, IObservableWithChange, IObserver, IReader, ISettableObservable, ITransaction, _setDerivedOpts } from './base.js';\nimport { DebugNameData, DebugOwner, IDebugNameData } from './debugName.js';\nimport { BugIndicatingError, DisposableStore, EqualityComparer, IDisposable, assertFn, onBugIndicatingError, strictEquals } from './commonFacade/deps.js';\nimport { getLogger } from './logging.js';\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFn?: ((reader: IReader) => T) | undefined): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tstrictEquals\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals\n\t);\n}\n\nexport function derivedWithSetter<T>(owner: DebugOwner | undefined, computeFn: (reader: IReader) => T, setter: (value: T, transaction: ITransaction | undefined) => void): ISettableObservable<T> {\n\treturn new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tsetter,\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: (() => void);\n\t},\n\tcomputeFn: (reader: IReader) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalsFn ?? strictEquals\n\t);\n}\n\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange,\n\t\tundefined,\n\t\toptions.equalityComparer ?? strictEquals\n\t);\n}\n\nexport function derivedWithStore<T>(computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(owner: object, computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(computeFnOrOwner: ((reader: IReader, store: DisposableStore) => T) | object, computeFnOrUndefined?: ((reader: IReader, store: DisposableStore) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: DisposableStore) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tconst store = new DisposableStore();\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tstore.clear();\n\t\t\treturn computeFn(r, store);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => store.dispose(),\n\t\tstrictEquals\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFnOrUndefined?: ((reader: IReader) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet store: DisposableStore | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (!store) {\n\t\t\t\tstore = new DisposableStore();\n\t\t\t} else {\n\t\t\t\tstore.clear();\n\t\t\t}\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => {\n\t\t\tif (store) {\n\t\t\t\tstore.dispose();\n\t\t\t\tstore = undefined;\n\t\t\t}\n\t\t},\n\t\tstrictEquals\n\t);\n}\n\nconst enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any> extends BaseObservable<T, void> implements IReader, IObserver {\n\tprivate state = DerivedState.initial;\n\tprivate value: T | undefined = undefined;\n\tprivate updateCount = 0;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined = undefined;\n\tprivate _isUpdating = false;\n\tprivate _isComputing = false;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleDerivedCreated(this);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis.state = DerivedState.initial;\n\t\tthis.value = undefined;\n\t\tgetLogger()?.handleDerivedCleared(this);\n\t\tfor (const d of this.dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tif (this._isComputing) {\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tif (this.observers.size === 0) {\n\t\t\tlet result;\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\ttry {\n\t\t\t\tthis._isReaderValid = true;\n\t\t\t\tresult = this._computeFn(this, this.createChangeSummary?.()!);\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t}\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this.state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tthis._recomputeIfNeeded();\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this.state !== DerivedState.upToDate);\n\t\t\treturn this.value!;\n\t\t}\n\t}\n\n\tprivate _recomputeIfNeeded() {\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\treturn;\n\t\t}\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tconst hadValue = this.state !== DerivedState.initial;\n\t\tconst oldValue = this.value;\n\t\tthis.state = DerivedState.upToDate;\n\n\t\tlet didChange = false;\n\n\t\tthis._isComputing = false; // TODO@hediet: Set to true and investigate diff editor scrolling issues! (also see test.skip('catches cyclic dependencies')\n\n\t\ttry {\n\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\ttry {\n\t\t\t\tthis._isReaderValid = true;\n\t\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\t\tthis.value = this._computeFn(this, changeSummary);\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\t\to.removeObserver(this);\n\t\t\t\t}\n\t\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t\t}\n\n\t\t\tdidChange = hadValue && !(this._equalityComparator(oldValue!, this.value));\n\n\t\t\tgetLogger()?.handleDerivedRecomputed(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue: this.value,\n\t\t\t\tchange: undefined,\n\t\t\t\tdidChange,\n\t\t\t\thadValue,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonBugIndicatingError(e);\n\t\t}\n\n\t\tthis._isComputing = false;\n\n\t\tif (didChange) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tif (this._isUpdating) {\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tthis.updateCount++;\n\t\tthis._isUpdating = true;\n\t\ttry {\n\t\t\tconst propagateBeginUpdate = this.updateCount === 1;\n\t\t\tif (this.state === DerivedState.upToDate) {\n\t\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propagateBeginUpdate) {\n\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis._isUpdating = false;\n\t\t}\n\t}\n\n\tprivate _removedObserverToCallEndUpdateOn: Set<IObserver> | null = null;\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount--;\n\t\tif (this.updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this.observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t\tif (this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tconst observers = [...this._removedObserverToCallEndUpdateOn];\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = null;\n\t\t\t\tfor (const r of observers) {\n\t\t\t\t\tr.endUpdate(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this.state === DerivedState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tlet shouldReact = false;\n\t\t\ttry {\n\t\t\t\tshouldReact = this._handleChange ? this._handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this.changeSummary!) : true;\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\n\t\t\tconst wasUpToDate = this.state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this.state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis.state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\tprivate _isReaderValid = false;\n\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\tif (!this._isReaderValid) { throw new BugIndicatingError('The reader object cannot be used outside its compute function!'); }\n\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tif (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(observer)) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn.delete(observer);\n\t\t\t} else {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tif (this.observers.has(observer) && this.updateCount > 0) {\n\t\t\tif (!this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = new Set();\n\t\t\t}\n\t\t\tthis._removedObserverToCallEndUpdateOn.add(observer);\n\t\t}\n\t\tsuper.removeObserver(observer);\n\t}\n\n\tpublic override log(): IObservableWithChange<T, void> {\n\t\tif (!getLogger()) {\n\t\t\tsuper.log();\n\t\t\tgetLogger()?.handleDerivedCreated(this);\n\t\t} else {\n\t\t\tsuper.log();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n\nexport class DerivedWithSetter<T, TChangeSummary = any> extends Derived<T, TChangeSummary> implements ISettableObservable<T> {\n\tconstructor(\n\t\tdebugNameData: DebugNameData,\n\t\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tcreateChangeSummary: (() => TChangeSummary) | undefined,\n\t\thandleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\thandleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tequalityComparator: EqualityComparer<T>,\n\t\tpublic readonly set: (value: T, tx: ITransaction | undefined) => void,\n\t) {\n\t\tsuper(\n\t\t\tdebugNameData,\n\t\t\tcomputeFn,\n\t\t\tcreateChangeSummary,\n\t\t\thandleChange,\n\t\t\thandleLastObserverRemoved,\n\t\t\tequalityComparator,\n\t\t);\n\t}\n}\n"]}