{"version":3,"sources":["file:///Users/kw/github/monaco-editor-core/out-editor-esm/vs/editor/standalone/browser/standaloneWebWorker.ts","vs/editor/standalone/browser/standaloneWebWorker.ts"],"names":[],"mappings":"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","file":"standaloneWebWorker.js","sourceRoot":"file:///Users/kw/github/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getAllMethodNames } from '../../../base/common/objects.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IWorkerDescriptor } from '../../../base/common/worker/simpleWorker.js';\nimport { EditorWorkerClient } from '../../browser/services/editorWorkerService.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { standaloneEditorWorkerDescriptor } from './standaloneServices.js';\n\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker<T extends object>(modelService: IModelService, opts: IWebWorkerOptions): MonacoWebWorker<T> {\n\treturn new MonacoWebWorkerImpl<T>(modelService, opts);\n}\n\n/**\n * A web worker that can provide a proxy to an arbitrary file.\n */\nexport interface MonacoWebWorker<T> {\n\t/**\n\t * Terminate the web worker, thus invalidating the returned proxy.\n\t */\n\tdispose(): void;\n\t/**\n\t * Get a proxy to the arbitrary loaded code.\n\t */\n\tgetProxy(): Promise<T>;\n\t/**\n\t * Synchronize (send) the models at `resources` to the web worker,\n\t * making them available in the monaco.worker.getMirrorModels().\n\t */\n\twithSyncedResources(resources: URI[]): Promise<T>;\n}\n\nexport interface IWebWorkerOptions {\n\t/**\n\t * The AMD moduleId to load.\n\t * It should export a function `create` that should return the exported proxy.\n\t */\n\tmoduleId: string;\n\t/**\n\t * The data to send over when calling create on the module.\n\t */\n\tcreateData?: any;\n\t/**\n\t * A label to be used to identify the web worker for debugging purposes.\n\t */\n\tlabel?: string;\n\t/**\n\t * An object that can be used by the web worker to make calls back to the main thread.\n\t */\n\thost?: any;\n\t/**\n\t * Keep idle models.\n\t * Defaults to false, which means that idle models will stop syncing after a while.\n\t */\n\tkeepIdleModels?: boolean;\n}\n\nclass MonacoWebWorkerImpl<T extends object> extends EditorWorkerClient implements MonacoWebWorker<T> {\n\n\tprivate readonly _foreignModuleId: string;\n\tprivate readonly _foreignModuleHost: { [method: string]: Function } | null;\n\tprivate _foreignModuleCreateData: any | null;\n\tprivate _foreignProxy: Promise<T> | null;\n\n\tconstructor(modelService: IModelService, opts: IWebWorkerOptions) {\n\t\tconst workerDescriptor: IWorkerDescriptor = {\n\t\t\tmoduleId: standaloneEditorWorkerDescriptor.moduleId,\n\t\t\tesmModuleLocation: standaloneEditorWorkerDescriptor.esmModuleLocation,\n\t\t\tlabel: opts.label,\n\t\t};\n\t\tsuper(workerDescriptor, opts.keepIdleModels || false, modelService);\n\t\tthis._foreignModuleId = opts.moduleId;\n\t\tthis._foreignModuleCreateData = opts.createData || null;\n\t\tthis._foreignModuleHost = opts.host || null;\n\t\tthis._foreignProxy = null;\n\t}\n\n\t// foreign host request\n\tpublic override fhr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _getForeignProxy(): Promise<T> {\n\t\tif (!this._foreignProxy) {\n\t\t\tthis._foreignProxy = this._getProxy().then((proxy) => {\n\t\t\t\tconst foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];\n\t\t\t\treturn proxy.$loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {\n\t\t\t\t\tthis._foreignModuleCreateData = null;\n\n\t\t\t\t\tconst proxyMethodRequest = (method: string, args: any[]): Promise<any> => {\n\t\t\t\t\t\treturn proxy.$fmr(method, args);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst createProxyMethod = (method: string, proxyMethodRequest: (method: string, args: any[]) => Promise<any>): () => Promise<any> => {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tconst args = Array.prototype.slice.call(arguments, 0);\n\t\t\t\t\t\t\treturn proxyMethodRequest(method, args);\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst foreignProxy = {} as any as T;\n\t\t\t\t\tfor (const foreignMethod of foreignMethods) {\n\t\t\t\t\t\t(<any>foreignProxy)[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn foreignProxy;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn this._foreignProxy;\n\t}\n\n\tpublic getProxy(): Promise<T> {\n\t\treturn this._getForeignProxy();\n\t}\n\n\tpublic withSyncedResources(resources: URI[]): Promise<T> {\n\t\treturn this.workerWithSyncedResources(resources).then(_ => this.getProxy());\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getAllMethodNames } from '../../../base/common/objects.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IWorkerDescriptor } from '../../../base/common/worker/simpleWorker.js';\nimport { EditorWorkerClient } from '../../browser/services/editorWorkerService.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { standaloneEditorWorkerDescriptor } from './standaloneServices.js';\n\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker<T extends object>(modelService: IModelService, opts: IWebWorkerOptions): MonacoWebWorker<T> {\n\treturn new MonacoWebWorkerImpl<T>(modelService, opts);\n}\n\n/**\n * A web worker that can provide a proxy to an arbitrary file.\n */\nexport interface MonacoWebWorker<T> {\n\t/**\n\t * Terminate the web worker, thus invalidating the returned proxy.\n\t */\n\tdispose(): void;\n\t/**\n\t * Get a proxy to the arbitrary loaded code.\n\t */\n\tgetProxy(): Promise<T>;\n\t/**\n\t * Synchronize (send) the models at `resources` to the web worker,\n\t * making them available in the monaco.worker.getMirrorModels().\n\t */\n\twithSyncedResources(resources: URI[]): Promise<T>;\n}\n\nexport interface IWebWorkerOptions {\n\t/**\n\t * The AMD moduleId to load.\n\t * It should export a function `create` that should return the exported proxy.\n\t */\n\tmoduleId: string;\n\t/**\n\t * The data to send over when calling create on the module.\n\t */\n\tcreateData?: any;\n\t/**\n\t * A label to be used to identify the web worker for debugging purposes.\n\t */\n\tlabel?: string;\n\t/**\n\t * An object that can be used by the web worker to make calls back to the main thread.\n\t */\n\thost?: any;\n\t/**\n\t * Keep idle models.\n\t * Defaults to false, which means that idle models will stop syncing after a while.\n\t */\n\tkeepIdleModels?: boolean;\n}\n\nclass MonacoWebWorkerImpl<T extends object> extends EditorWorkerClient implements MonacoWebWorker<T> {\n\n\tprivate readonly _foreignModuleId: string;\n\tprivate readonly _foreignModuleHost: { [method: string]: Function } | null;\n\tprivate _foreignModuleCreateData: any | null;\n\tprivate _foreignProxy: Promise<T> | null;\n\n\tconstructor(modelService: IModelService, opts: IWebWorkerOptions) {\n\t\tconst workerDescriptor: IWorkerDescriptor = {\n\t\t\tmoduleId: standaloneEditorWorkerDescriptor.moduleId,\n\t\t\tesmModuleLocation: standaloneEditorWorkerDescriptor.esmModuleLocation,\n\t\t\tlabel: opts.label,\n\t\t};\n\t\tsuper(workerDescriptor, opts.keepIdleModels || false, modelService);\n\t\tthis._foreignModuleId = opts.moduleId;\n\t\tthis._foreignModuleCreateData = opts.createData || null;\n\t\tthis._foreignModuleHost = opts.host || null;\n\t\tthis._foreignProxy = null;\n\t}\n\n\t// foreign host request\n\tpublic override fhr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _getForeignProxy(): Promise<T> {\n\t\tif (!this._foreignProxy) {\n\t\t\tthis._foreignProxy = this._getProxy().then((proxy) => {\n\t\t\t\tconst foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];\n\t\t\t\treturn proxy.$loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {\n\t\t\t\t\tthis._foreignModuleCreateData = null;\n\n\t\t\t\t\tconst proxyMethodRequest = (method: string, args: any[]): Promise<any> => {\n\t\t\t\t\t\treturn proxy.$fmr(method, args);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst createProxyMethod = (method: string, proxyMethodRequest: (method: string, args: any[]) => Promise<any>): () => Promise<any> => {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tconst args = Array.prototype.slice.call(arguments, 0);\n\t\t\t\t\t\t\treturn proxyMethodRequest(method, args);\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst foreignProxy = {} as any as T;\n\t\t\t\t\tfor (const foreignMethod of foreignMethods) {\n\t\t\t\t\t\t(<any>foreignProxy)[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn foreignProxy;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn this._foreignProxy;\n\t}\n\n\tpublic getProxy(): Promise<T> {\n\t\treturn this._getForeignProxy();\n\t}\n\n\tpublic withSyncedResources(resources: URI[]): Promise<T> {\n\t\treturn this.workerWithSyncedResources(resources).then(_ => this.getProxy());\n\t}\n}\n"]}