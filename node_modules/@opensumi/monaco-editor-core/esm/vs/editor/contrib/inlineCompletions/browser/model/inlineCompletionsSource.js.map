{"version":3,"sources":["file:///Users/kw/github/monaco-editor-core/out-editor-esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsSource.ts","vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsSource.ts"],"names":[],"mappings":"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","file":"inlineCompletionsSource.js","sourceRoot":"file:///Users/kw/github/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { equalsIfDefined, itemEquals } from '../../../../../base/common/equals.js';\nimport { matchesSubString } from '../../../../../base/common/filters.js';\nimport { Disposable, IDisposable, MutableDisposable } from '../../../../../base/common/lifecycle.js';\nimport { IObservable, IReader, ISettableObservable, ITransaction, derivedOpts, disposableObservableValue, observableFromEvent, observableValue, transaction } from '../../../../../base/common/observable.js';\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { IContextKeyService } from '../../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../../platform/log/common/log.js';\nimport { observableConfigValue } from '../../../../../platform/observable/common/platformObservableUtils.js';\nimport { OffsetEdit, SingleOffsetEdit } from '../../../../common/core/offsetEdit.js';\nimport { OffsetRange } from '../../../../common/core/offsetRange.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { SingleTextEdit, StringText } from '../../../../common/core/textEdit.js';\nimport { TextLength } from '../../../../common/core/textLength.js';\nimport { linesDiffComputers } from '../../../../common/diff/linesDiffComputers.js';\nimport { InlineCompletionContext, InlineCompletionTriggerKind } from '../../../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../../../common/languages/languageConfigurationRegistry.js';\nimport { EndOfLinePreference, ITextModel } from '../../../../common/model.js';\nimport { IFeatureDebounceInformation } from '../../../../common/services/languageFeatureDebounce.js';\nimport { ILanguageFeaturesService } from '../../../../common/services/languageFeatures.js';\nimport { IModelContentChange, IModelContentChangedEvent } from '../../../../common/textModelEvents.js';\nimport { InlineCompletionItem, InlineCompletionProviderResult, provideInlineCompletions } from './provideInlineCompletions.js';\nimport { singleTextRemoveCommonPrefix } from './singleTextEditHelpers.js';\n\nexport class InlineCompletionsSource extends Disposable {\n\tprivate static _requestId = 0;\n\n\tprivate readonly _updateOperation = this._register(new MutableDisposable<UpdateOperation>());\n\tpublic readonly inlineCompletions = disposableObservableValue<UpToDateInlineCompletions | undefined>('inlineCompletions', undefined);\n\tpublic readonly suggestWidgetInlineCompletions = disposableObservableValue<UpToDateInlineCompletions | undefined>('suggestWidgetInlineCompletions', undefined);\n\n\tprivate readonly _loggingEnabled = observableConfigValue('editor.inlineSuggest.logFetch', false, this._configurationService).recomputeInitiallyAndOnChange(this._store);\n\tprivate readonly _invalidationDelay = observableConfigValue<number>('editor.inlineSuggest.edits.experimental.invalidationDelay', 4000, this._configurationService).recomputeInitiallyAndOnChange(this._store);\n\n\tprivate readonly _structuredFetchLogger = this._register(this._instantiationService.createInstance(StructuredLogger.cast<\n\t\t{ kind: 'start'; requestId: number; context: unknown } & IRecordableEditorLogEntry\n\t\t| { kind: 'end'; error: any; durationMs: number; result: unknown; requestId: number } & IRecordableLogEntry\n\t>(),\n\t\t'editor.inlineSuggest.logFetch.commandId'\n\t));\n\n\tconstructor(\n\t\tprivate readonly _textModel: ITextModel,\n\t\tprivate readonly _versionId: IObservable<number | null>,\n\t\tprivate readonly _debounceValue: IFeatureDebounceInformation,\n\t\t@ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(this._textModel.onDidChangeContent((e) => {\n\t\t\tthis._updateOperation.clear();\n\n\t\t\tconst inlineCompletions = this.inlineCompletions.get();\n\t\t\tif (inlineCompletions) {\n\t\t\t\ttransaction(tx => {\n\t\t\t\t\tinlineCompletions.acceptTextModelChangeEvent(e, tx);\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate _log(entry:\n\t\t{ sourceId: string; kind: 'start'; requestId: number; context: unknown } & IRecordableEditorLogEntry\n\t\t| { sourceId: string; kind: 'end'; error: any; durationMs: number; result: unknown; requestId: number } & IRecordableLogEntry\n\t) {\n\t\tif (this._loggingEnabled.get()) {\n\t\t\tthis._logService.info(formatRecordableLogEntry(entry));\n\t\t}\n\t\tthis._structuredFetchLogger.log(entry);\n\t}\n\n\tpublic readonly loading = observableValue(this, false);\n\n\tpublic fetch(position: Position, context: InlineCompletionContext, activeInlineCompletion: InlineCompletionWithUpdatedRange | undefined): Promise<boolean> {\n\t\tconst request = new UpdateRequest(position, context, this._textModel.getVersionId());\n\n\t\tconst target = context.selectedSuggestionInfo ? this.suggestWidgetInlineCompletions : this.inlineCompletions;\n\n\t\tif (this._updateOperation.value?.request.satisfies(request)) {\n\t\t\treturn this._updateOperation.value.promise;\n\t\t} else if (target.get()?.request.satisfies(request)) {\n\t\t\treturn Promise.resolve(true);\n\t\t}\n\n\t\tthis.loading.set(true, undefined);\n\n\t\tconst updateOngoing = !!this._updateOperation.value;\n\t\tthis._updateOperation.clear();\n\n\t\tconst source = new CancellationTokenSource();\n\n\t\tconst promise = (async () => {\n\t\t\tconst shouldDebounce = updateOngoing || context.triggerKind === InlineCompletionTriggerKind.Automatic;\n\t\t\tif (shouldDebounce) {\n\t\t\t\t// This debounces the operation\n\t\t\t\tawait wait(this._debounceValue.get(this._textModel), source.token);\n\t\t\t}\n\n\t\t\tif (source.token.isCancellationRequested || this._store.isDisposed || this._textModel.getVersionId() !== request.versionId) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst requestId = InlineCompletionsSource._requestId++;\n\t\t\tif (this._loggingEnabled.get() || this._structuredFetchLogger.isEnabled.get()) {\n\t\t\t\tthis._log({ sourceId: 'InlineCompletions.fetch', kind: 'start', requestId, modelUri: this._textModel.uri.toString(), modelVersion: this._textModel.getVersionId(), context: { triggerKind: context.triggerKind }, time: Date.now() });\n\t\t\t}\n\n\t\t\tconst startTime = new Date();\n\t\t\tlet updatedCompletions: InlineCompletionProviderResult | undefined = undefined;\n\t\t\tlet error: any = undefined;\n\t\t\ttry {\n\t\t\t\tupdatedCompletions = await provideInlineCompletions(\n\t\t\t\t\tthis._languageFeaturesService.inlineCompletionsProvider,\n\t\t\t\t\tposition,\n\t\t\t\t\tthis._textModel,\n\t\t\t\t\tcontext,\n\t\t\t\t\tsource.token,\n\t\t\t\t\tthis._languageConfigurationService\n\t\t\t\t);\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\tif (this._loggingEnabled.get() || this._structuredFetchLogger.isEnabled.get()) {\n\t\t\t\t\tif (source.token.isCancellationRequested || this._store.isDisposed || this._textModel.getVersionId() !== request.versionId) {\n\t\t\t\t\t\terror = 'canceled';\n\t\t\t\t\t}\n\t\t\t\t\tconst result = updatedCompletions?.completions.map(c => ({\n\t\t\t\t\t\trange: c.range.toString(),\n\t\t\t\t\t\ttext: c.insertText,\n\t\t\t\t\t\tisInlineEdit: !!c.sourceInlineCompletion.isInlineEdit,\n\t\t\t\t\t\tsource: c.source.provider.groupId,\n\t\t\t\t\t}));\n\t\t\t\t\tthis._log({ sourceId: 'InlineCompletions.fetch', kind: 'end', requestId, durationMs: (Date.now() - startTime.getTime()), error, result, time: Date.now() });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (source.token.isCancellationRequested || this._store.isDisposed || this._textModel.getVersionId() !== request.versionId) {\n\t\t\t\tupdatedCompletions.dispose();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Reuse Inline Edit if possible\n\t\t\tif (activeInlineCompletion && activeInlineCompletion.isInlineEdit && (activeInlineCompletion.canBeReused(this._textModel, position) || updatedCompletions.has(activeInlineCompletion.inlineCompletion) /* Inline Edit wins over completions if it's already been shown*/)) {\n\t\t\t\tupdatedCompletions.dispose();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst endTime = new Date();\n\t\t\tthis._debounceValue.update(this._textModel, endTime.getTime() - startTime.getTime());\n\n\t\t\t// Reuse Inline Completion if possible\n\t\t\tconst completions = new UpToDateInlineCompletions(updatedCompletions, request, this._textModel, this._versionId, this._invalidationDelay);\n\t\t\tif (activeInlineCompletion && !activeInlineCompletion.isInlineEdit && activeInlineCompletion.canBeReused(this._textModel, position)) {\n\t\t\t\tconst asInlineCompletion = activeInlineCompletion.toInlineCompletion(undefined);\n\t\t\t\tif (!updatedCompletions.has(asInlineCompletion)) {\n\t\t\t\t\tcompletions.prepend(activeInlineCompletion.inlineCompletion, asInlineCompletion.range, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._updateOperation.clear();\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description Update completions with provider result */\n\t\t\t\ttarget.set(completions, tx);\n\t\t\t\tthis.loading.set(false, tx);\n\t\t\t});\n\n\t\t\treturn true;\n\t\t})();\n\n\t\tconst updateOperation = new UpdateOperation(request, source, promise);\n\t\tthis._updateOperation.value = updateOperation;\n\n\t\treturn promise;\n\t}\n\n\tpublic clear(tx: ITransaction): void {\n\t\tthis._updateOperation.clear();\n\t\tthis.inlineCompletions.set(undefined, tx);\n\t\tthis.suggestWidgetInlineCompletions.set(undefined, tx);\n\t}\n\n\tpublic clearSuggestWidgetInlineCompletions(tx: ITransaction): void {\n\t\tif (this._updateOperation.value?.request.context.selectedSuggestionInfo) {\n\t\t\tthis._updateOperation.clear();\n\t\t}\n\t\tthis.suggestWidgetInlineCompletions.set(undefined, tx);\n\t}\n\n\tpublic cancelUpdate(): void {\n\t\tthis._updateOperation.clear();\n\t}\n}\n\nfunction wait(ms: number, cancellationToken?: CancellationToken): Promise<void> {\n\treturn new Promise(resolve => {\n\t\tlet d: IDisposable | undefined = undefined;\n\t\tconst handle = setTimeout(() => {\n\t\t\tif (d) { d.dispose(); }\n\t\t\tresolve();\n\t\t}, ms);\n\t\tif (cancellationToken) {\n\t\t\td = cancellationToken.onCancellationRequested(() => {\n\t\t\t\tclearTimeout(handle);\n\t\t\t\tif (d) { d.dispose(); }\n\t\t\t\tresolve();\n\t\t\t});\n\t\t}\n\t});\n}\n\nclass UpdateRequest {\n\tconstructor(\n\t\tpublic readonly position: Position,\n\t\tpublic readonly context: InlineCompletionContext,\n\t\tpublic readonly versionId: number,\n\t) {\n\t}\n\n\tpublic satisfies(other: UpdateRequest): boolean {\n\t\treturn this.position.equals(other.position)\n\t\t\t&& equalsIfDefined(this.context.selectedSuggestionInfo, other.context.selectedSuggestionInfo, itemEquals())\n\t\t\t&& (other.context.triggerKind === InlineCompletionTriggerKind.Automatic\n\t\t\t\t|| this.context.triggerKind === InlineCompletionTriggerKind.Explicit)\n\t\t\t&& this.versionId === other.versionId;\n\t}\n\n\tpublic get isExplicitRequest() {\n\t\treturn this.context.triggerKind === InlineCompletionTriggerKind.Explicit;\n\t}\n}\n\nclass UpdateOperation implements IDisposable {\n\tconstructor(\n\t\tpublic readonly request: UpdateRequest,\n\t\tpublic readonly cancellationTokenSource: CancellationTokenSource,\n\t\tpublic readonly promise: Promise<boolean>,\n\t) {\n\t}\n\n\tdispose() {\n\t\tthis.cancellationTokenSource.cancel();\n\t}\n}\n\nexport class UpToDateInlineCompletions implements IDisposable {\n\tprivate readonly _inlineCompletions: InlineCompletionWithUpdatedRange[];\n\tpublic get inlineCompletions(): ReadonlyArray<InlineCompletionWithUpdatedRange> { return this._inlineCompletions; }\n\n\tprivate _refCount = 1;\n\tprivate readonly _prependedInlineCompletionItems: InlineCompletionItem[] = [];\n\n\tconstructor(\n\t\tprivate readonly inlineCompletionProviderResult: InlineCompletionProviderResult,\n\t\tpublic readonly request: UpdateRequest,\n\t\tprivate readonly _textModel: ITextModel,\n\t\tprivate readonly _versionId: IObservable<number | null>,\n\t\tprivate readonly _invalidationDelay: IObservable<number>,\n\t) {\n\t\tconst ids = _textModel.deltaDecorations([], inlineCompletionProviderResult.completions.map(i => ({\n\t\t\trange: i.range,\n\t\t\toptions: {\n\t\t\t\tdescription: 'inline-completion-tracking-range'\n\t\t\t},\n\t\t})));\n\n\t\tthis._inlineCompletions = inlineCompletionProviderResult.completions.map(\n\t\t\t(i, index) => new InlineCompletionWithUpdatedRange(i, ids[index], this._textModel, this._versionId, this._invalidationDelay, this.request)\n\t\t);\n\t}\n\n\tpublic acceptTextModelChangeEvent(e: IModelContentChangedEvent, tx: ITransaction) {\n\t\tfor (const inlineCompletion of this._inlineCompletions) {\n\t\t\tinlineCompletion.acceptTextModelChangeEvent(e, tx);\n\t\t}\n\t}\n\n\tpublic clone(): this {\n\t\tthis._refCount++;\n\t\treturn this;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._refCount--;\n\t\tif (this._refCount === 0) {\n\t\t\tsetTimeout(() => {\n\t\t\t\t// To fix https://github.com/microsoft/vscode/issues/188348\n\t\t\t\tif (!this._textModel.isDisposed()) {\n\t\t\t\t\t// This is just cleanup. It's ok if it happens with a delay.\n\t\t\t\t\tthis._textModel.deltaDecorations(this._inlineCompletions.map(i => i.decorationId), []);\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t\tthis.inlineCompletionProviderResult.dispose();\n\t\t\tfor (const i of this._prependedInlineCompletionItems) {\n\t\t\t\ti.source.removeRef();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic prepend(inlineCompletion: InlineCompletionItem, range: Range, addRefToSource: boolean): void {\n\t\tif (addRefToSource) {\n\t\t\tinlineCompletion.source.addRef();\n\t\t}\n\n\t\tconst id = this._textModel.deltaDecorations([], [{\n\t\t\trange,\n\t\t\toptions: {\n\t\t\t\tdescription: 'inline-completion-tracking-range'\n\t\t\t},\n\t\t}])[0];\n\t\tthis._inlineCompletions.unshift(new InlineCompletionWithUpdatedRange(inlineCompletion, id, this._textModel, this._versionId, this._invalidationDelay, this.request));\n\t\tthis._prependedInlineCompletionItems.push(inlineCompletion);\n\t}\n}\n\nexport class InlineCompletionWithUpdatedRange {\n\tpublic readonly semanticId = JSON.stringify([\n\t\tthis.inlineCompletion.filterText,\n\t\tthis.inlineCompletion.insertText,\n\t\tthis.inlineCompletion.range.getStartPosition().toString()\n\t]);\n\n\tpublic get forwardStable() {\n\t\treturn this.source.inlineCompletions.enableForwardStability ?? false;\n\t}\n\n\tprivate readonly _updatedRange = derivedOpts<Range | null>({ owner: this, equalsFn: Range.equalsRange }, reader => {\n\t\tif (this._inlineEdit.read(reader)) {\n\t\t\tconst edit = this.toSingleTextEdit(reader);\n\t\t\treturn (edit.isEmpty ? null : edit.range);\n\t\t} else {\n\t\t\tthis._modelVersion.read(reader);\n\t\t\treturn this._textModel.getDecorationRange(this.decorationId);\n\t\t}\n\t});\n\n\t/**\n\t * This will be null for ghost text completions\n\t */\n\tprivate _inlineEdit: ISettableObservable<OffsetEdit | null>;\n\tpublic get inlineEdit(): IObservable<OffsetEdit | null> { return this._inlineEdit; }\n\n\tpublic get source() { return this.inlineCompletion.source; }\n\tpublic get sourceInlineCompletion() { return this.inlineCompletion.sourceInlineCompletion; }\n\tpublic get isInlineEdit() { return this.inlineCompletion.sourceInlineCompletion.isInlineEdit; }\n\n\tprivate _invalidationTime: number | undefined = Date.now() + this._invalidationDelay.get();\n\n\tprivate _lastChangePartOfInlineEdit = false;\n\n\tconstructor(\n\t\tpublic readonly inlineCompletion: InlineCompletionItem,\n\t\tpublic readonly decorationId: string,\n\t\tprivate readonly _textModel: ITextModel,\n\t\tprivate readonly _modelVersion: IObservable<number | null>,\n\t\tprivate readonly _invalidationDelay: IObservable<number>,\n\t\tpublic readonly request: UpdateRequest,\n\t) {\n\t\tconst inlineCompletions = this.inlineCompletion.source.inlineCompletions.items;\n\t\tif (inlineCompletions.length > 0 && inlineCompletions[inlineCompletions.length - 1].isInlineEdit) {\n\t\t\tthis._inlineEdit = observableValue(this, this._toIndividualEdits(this.inlineCompletion.range, this.inlineCompletion.insertText));\n\t\t} else {\n\t\t\tthis._inlineEdit = observableValue(this, null);\n\t\t}\n\t}\n\n\tprivate _toIndividualEdits(editRange: Range, _replaceText: string): OffsetEdit {\n\t\tconst eol = this._textModel.getEOL();\n\t\tconst editOriginalText = this._textModel.getValueInRange(editRange);\n\t\tconst editReplaceText = _replaceText.replace(/\\r\\n|\\r|\\n/g, eol);\n\n\t\tconst diffAlgorithm = linesDiffComputers.getDefault();\n\t\tconst lineDiffs = diffAlgorithm.computeDiff(\n\t\t\tsplitLines(editOriginalText),\n\t\t\tsplitLines(editReplaceText),\n\t\t\t{\n\t\t\t\tignoreTrimWhitespace: false,\n\t\t\t\tcomputeMoves: false,\n\t\t\t\textendToSubwords: true,\n\t\t\t\tmaxComputationTimeMs: 500,\n\t\t\t}\n\t\t);\n\n\t\tconst innerChanges = lineDiffs.changes.flatMap(c => c.innerChanges ?? []);\n\t\tif (innerChanges.length === 0) {\n\t\t\tconst startOffset = this._textModel.getOffsetAt(editRange.getStartPosition());\n\t\t\treturn new OffsetEdit(\n\t\t\t\t[new SingleOffsetEdit(OffsetRange.ofStartAndLength(startOffset, editOriginalText.length), editReplaceText)]\n\t\t\t);\n\t\t}\n\n\t\tfunction addRangeToPos(pos: Position, range: Range): Range {\n\t\t\tconst start = TextLength.fromPosition(range.getStartPosition());\n\t\t\treturn TextLength.ofRange(range).createRange(start.addToPosition(pos));\n\t\t}\n\n\t\tconst modifiedText = new StringText(editReplaceText);\n\n\t\treturn new OffsetEdit(\n\t\t\tinnerChanges.map(c => {\n\t\t\t\tconst range = addRangeToPos(editRange.getStartPosition(), c.originalRange);\n\t\t\t\tconst startOffset = this._textModel.getOffsetAt(range.getStartPosition());\n\t\t\t\tconst endOffset = this._textModel.getOffsetAt(range.getEndPosition());\n\t\t\t\tconst originalRange = OffsetRange.ofStartAndLength(startOffset, endOffset - startOffset);\n\n\t\t\t\t// TODO: EOL are not properly trimmed by the diffAlgorithm #12680\n\t\t\t\tconst replaceText = modifiedText.getValueOfRange(c.modifiedRange);\n\t\t\t\tconst oldText = this._textModel.getValueInRange(range);\n\t\t\t\tif (replaceText.endsWith(eol) && oldText.endsWith(eol)) {\n\t\t\t\t\treturn new SingleOffsetEdit(originalRange.deltaEnd(-eol.length), replaceText.slice(0, -eol.length));\n\t\t\t\t}\n\n\t\t\t\treturn new SingleOffsetEdit(originalRange, replaceText);\n\t\t\t})\n\t\t);\n\t}\n\n\tpublic acceptTextModelChangeEvent(e: IModelContentChangedEvent, tx: ITransaction): void {\n\t\tthis._lastChangePartOfInlineEdit = false;\n\n\t\tconst offsetEdit = this._inlineEdit.get();\n\t\tif (!offsetEdit) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst editUpdates = offsetEdit.edits.map(edit => acceptTextModelChange(edit, e.changes));\n\t\tconst newEdits = editUpdates.filter(({ changeType }) => changeType !== 'fullyAccepted').map(({ edit }) => edit);\n\n\t\tconst emptyEdit = newEdits.find(edit => edit.isEmpty);\n\t\tif (emptyEdit || newEdits.length === 0) {\n\t\t\t// Either a change collided with one of our edits, so we will have to drop the completion\n\t\t\t// Or the completion has been typed by the user\n\t\t\tthis._inlineEdit.set(new OffsetEdit([emptyEdit ?? new SingleOffsetEdit(new OffsetRange(0, 0), '')]), tx);\n\t\t\treturn;\n\t\t}\n\n\t\tconst changePartiallyAcceptsEdit = editUpdates.some(({ changeType }) => changeType === 'partiallyAccepted' || changeType === 'fullyAccepted');\n\n\t\tif (changePartiallyAcceptsEdit) {\n\t\t\tthis._invalidationTime = undefined;\n\t\t}\n\t\tif (this._invalidationTime && this._invalidationTime < Date.now()) {\n\t\t\t// The completion has been shown for a while and the user\n\t\t\t// has been working on a different part of the document, so invalidate it\n\t\t\tthis._inlineEdit.set(new OffsetEdit([new SingleOffsetEdit(new OffsetRange(0, 0), '')]), tx);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lastChangePartOfInlineEdit = changePartiallyAcceptsEdit;\n\t\tthis._inlineEdit.set(new OffsetEdit(newEdits), tx);\n\n\t\tfunction acceptTextModelChange(edit: SingleOffsetEdit, changes: readonly IModelContentChange[]): { edit: SingleOffsetEdit; changeType: 'move' | 'partiallyAccepted' | 'fullyAccepted' } {\n\t\t\tlet start = edit.replaceRange.start;\n\t\t\tlet end = edit.replaceRange.endExclusive;\n\t\t\tlet newText = edit.newText;\n\t\t\tlet changeType: 'move' | 'partiallyAccepted' | 'fullyAccepted' = 'move';\n\t\t\tfor (let i = changes.length - 1; i >= 0; i--) {\n\t\t\t\tconst change = changes[i];\n\n\t\t\t\t// Edit is an insertion: user inserted text at the start of the completion\n\t\t\t\tif (edit.replaceRange.isEmpty && change.rangeLength === 0 && change.rangeOffset === start && newText.startsWith(change.text)) {\n\t\t\t\t\tstart += change.text.length;\n\t\t\t\t\tend = Math.max(start, end);\n\t\t\t\t\tnewText = newText.substring(change.text.length);\n\t\t\t\t\tchangeType = newText.length === 0 ? 'fullyAccepted' : 'partiallyAccepted';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Edit is a deletion: user deleted text inside the deletion range\n\t\t\t\tif (!edit.replaceRange.isEmpty && change.text.length === 0 && change.rangeOffset >= start && change.rangeOffset + change.rangeLength <= end) {\n\t\t\t\t\tend -= change.rangeLength;\n\t\t\t\t\tchangeType = start === end ? 'fullyAccepted' : 'partiallyAccepted';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (change.rangeOffset > end) {\n\t\t\t\t\t// the change happens after the completion range\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (change.rangeOffset + change.rangeLength < start) {\n\t\t\t\t\t// the change happens before the completion range\n\t\t\t\t\tstart += change.text.length - change.rangeLength;\n\t\t\t\t\tend += change.text.length - change.rangeLength;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// The change intersects the completion, so we will have to drop the completion\n\t\t\t\tstart = change.rangeOffset;\n\t\t\t\tend = change.rangeOffset;\n\t\t\t\tnewText = '';\n\t\t\t}\n\t\t\treturn { edit: new SingleOffsetEdit(new OffsetRange(start, end), newText), changeType };\n\t\t}\n\t}\n\n\tpublic toInlineCompletion(reader: IReader | undefined): InlineCompletionItem {\n\t\tconst singleTextEdit = this.toSingleTextEdit(reader);\n\t\treturn this.inlineCompletion.withRangeInsertTextAndFilterText(singleTextEdit.range, singleTextEdit.text, singleTextEdit.text);\n\t}\n\n\tpublic toSingleTextEdit(reader: IReader | undefined): SingleTextEdit {\n\t\tthis._modelVersion.read(reader);\n\t\tconst offsetEdit = this._inlineEdit.read(reader);\n\t\tif (!offsetEdit) {\n\t\t\treturn new SingleTextEdit(this._updatedRange.read(reader) ?? emptyRange, this.inlineCompletion.insertText);\n\t\t}\n\n\t\tconst startOffset = offsetEdit.edits[0].replaceRange.start;\n\t\tconst endOffset = offsetEdit.edits[offsetEdit.edits.length - 1].replaceRange.endExclusive;\n\t\tconst overallOffsetRange = new OffsetRange(startOffset, endOffset);\n\t\tconst overallLnColRange = Range.fromPositions(\n\t\t\tthis._textModel.getPositionAt(overallOffsetRange.start),\n\t\t\tthis._textModel.getPositionAt(overallOffsetRange.endExclusive)\n\t\t);\n\t\tlet text = this._textModel.getValueInRange(overallLnColRange);\n\t\tfor (let i = offsetEdit.edits.length - 1; i >= 0; i--) {\n\t\t\tconst edit = offsetEdit.edits[i];\n\t\t\tconst relativeStartOffset = edit.replaceRange.start - startOffset;\n\t\t\tconst relativeEndOffset = edit.replaceRange.endExclusive - startOffset;\n\t\t\ttext = text.substring(0, relativeStartOffset) + edit.newText + text.substring(relativeEndOffset);\n\t\t}\n\t\treturn new SingleTextEdit(overallLnColRange, text);\n\t}\n\n\tpublic isVisible(model: ITextModel, cursorPosition: Position, reader: IReader | undefined): boolean {\n\t\tconst minimizedReplacement = singleTextRemoveCommonPrefix(this._toFilterTextReplacement(reader), model);\n\t\tconst updatedRange = this._updatedRange.read(reader);\n\t\tif (\n\t\t\t!updatedRange\n\t\t\t|| !this.inlineCompletion.range.getStartPosition().equals(updatedRange.getStartPosition())\n\t\t\t|| cursorPosition.lineNumber !== minimizedReplacement.range.startLineNumber\n\t\t\t|| minimizedReplacement.isEmpty // if the completion is empty after removing the common prefix of the completion and the model, the completion item would not be visible\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We might consider comparing by .toLowerText, but this requires GhostTextReplacement\n\t\tconst originalValue = model.getValueInRange(minimizedReplacement.range, EndOfLinePreference.LF);\n\t\tconst filterText = minimizedReplacement.text;\n\n\t\tconst cursorPosIndex = Math.max(0, cursorPosition.column - minimizedReplacement.range.startColumn);\n\n\t\tlet filterTextBefore = filterText.substring(0, cursorPosIndex);\n\t\tlet filterTextAfter = filterText.substring(cursorPosIndex);\n\n\t\tlet originalValueBefore = originalValue.substring(0, cursorPosIndex);\n\t\tlet originalValueAfter = originalValue.substring(cursorPosIndex);\n\n\t\tconst originalValueIndent = model.getLineIndentColumn(minimizedReplacement.range.startLineNumber);\n\t\tif (minimizedReplacement.range.startColumn <= originalValueIndent) {\n\t\t\t// Remove indentation\n\t\t\toriginalValueBefore = originalValueBefore.trimStart();\n\t\t\tif (originalValueBefore.length === 0) {\n\t\t\t\toriginalValueAfter = originalValueAfter.trimStart();\n\t\t\t}\n\t\t\tfilterTextBefore = filterTextBefore.trimStart();\n\t\t\tif (filterTextBefore.length === 0) {\n\t\t\t\tfilterTextAfter = filterTextAfter.trimStart();\n\t\t\t}\n\t\t}\n\n\t\treturn filterTextBefore.startsWith(originalValueBefore)\n\t\t\t&& !!matchesSubString(originalValueAfter, filterTextAfter);\n\t}\n\n\tpublic canBeReused(model: ITextModel, position: Position): boolean {\n\t\tconst inlineEdit = this._inlineEdit.get();\n\t\tif (inlineEdit !== null) {\n\t\t\treturn model === this._textModel\n\t\t\t\t&& !inlineEdit.isEmpty\n\t\t\t\t&& this._lastChangePartOfInlineEdit;\n\t\t}\n\n\t\tconst updatedRange = this._updatedRange.read(undefined);\n\t\tconst result = !!updatedRange\n\t\t\t&& updatedRange.containsPosition(position)\n\t\t\t&& this.isVisible(model, position, undefined)\n\t\t\t&& TextLength.ofRange(updatedRange).isGreaterThanOrEqualTo(TextLength.ofRange(this.inlineCompletion.range));\n\t\treturn result;\n\t}\n\n\tprivate _toFilterTextReplacement(reader: IReader | undefined): SingleTextEdit {\n\t\tconst inlineCompletion = this.toInlineCompletion(reader);\n\t\treturn new SingleTextEdit(inlineCompletion.range, inlineCompletion.filterText);\n\t}\n}\n\nconst emptyRange = new Range(1, 1, 1, 1);\n\ninterface IRecordableLogEntry {\n\tsourceId: string;\n\ttime: number;\n}\n\nexport interface IRecordableEditorLogEntry extends IRecordableLogEntry {\n\tmodelUri: string;\n\tmodelVersion: number;\n}\n\n/**\n * The sourceLabel must not contain '@'!\n*/\nexport function formatRecordableLogEntry<T extends IRecordableLogEntry>(entry: T): string {\n\treturn entry.sourceId + ' @@ ' + JSON.stringify({ ...entry, sourceId: undefined });\n}\n\nexport class StructuredLogger<T extends IRecordableLogEntry> extends Disposable {\n\tpublic static cast<T extends IRecordableLogEntry>(): typeof StructuredLogger<T> {\n\t\treturn this as typeof StructuredLogger<T>;\n\t}\n\n\tprivate readonly _contextKeyValue = observableContextKey<string>(this._contextKey, this._contextKeyService).recomputeInitiallyAndOnChange(this._store);\n\n\tconstructor(\n\t\tprivate readonly _contextKey: string,\n\t\t@IContextKeyService private readonly _contextKeyService: IContextKeyService,\n\t\t@ICommandService private readonly _commandService: ICommandService,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic readonly isEnabled = this._contextKeyValue.map(v => v !== undefined);\n\n\tpublic log(data: T): boolean {\n\t\tconst commandId = this._contextKeyValue.get();\n\t\tif (!commandId) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._commandService.executeCommand(commandId, data);\n\t\treturn true;\n\t}\n}\n\nexport function observableContextKey<T>(key: string, contextKeyService: IContextKeyService): IObservable<T | undefined> {\n\treturn observableFromEvent(contextKeyService.onDidChangeContext, () => contextKeyService.getContextKeyValue<T>(key));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from '../../../../../base/common/cancellation.js';\nimport { equalsIfDefined, itemEquals } from '../../../../../base/common/equals.js';\nimport { matchesSubString } from '../../../../../base/common/filters.js';\nimport { Disposable, IDisposable, MutableDisposable } from '../../../../../base/common/lifecycle.js';\nimport { IObservable, IReader, ISettableObservable, ITransaction, derivedOpts, disposableObservableValue, observableFromEvent, observableValue, transaction } from '../../../../../base/common/observable.js';\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { IContextKeyService } from '../../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../../platform/log/common/log.js';\nimport { observableConfigValue } from '../../../../../platform/observable/common/platformObservableUtils.js';\nimport { OffsetEdit, SingleOffsetEdit } from '../../../../common/core/offsetEdit.js';\nimport { OffsetRange } from '../../../../common/core/offsetRange.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { SingleTextEdit, StringText } from '../../../../common/core/textEdit.js';\nimport { TextLength } from '../../../../common/core/textLength.js';\nimport { linesDiffComputers } from '../../../../common/diff/linesDiffComputers.js';\nimport { InlineCompletionContext, InlineCompletionTriggerKind } from '../../../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../../../common/languages/languageConfigurationRegistry.js';\nimport { EndOfLinePreference, ITextModel } from '../../../../common/model.js';\nimport { IFeatureDebounceInformation } from '../../../../common/services/languageFeatureDebounce.js';\nimport { ILanguageFeaturesService } from '../../../../common/services/languageFeatures.js';\nimport { IModelContentChange, IModelContentChangedEvent } from '../../../../common/textModelEvents.js';\nimport { InlineCompletionItem, InlineCompletionProviderResult, provideInlineCompletions } from './provideInlineCompletions.js';\nimport { singleTextRemoveCommonPrefix } from './singleTextEditHelpers.js';\n\nexport class InlineCompletionsSource extends Disposable {\n\tprivate static _requestId = 0;\n\n\tprivate readonly _updateOperation = this._register(new MutableDisposable<UpdateOperation>());\n\tpublic readonly inlineCompletions = disposableObservableValue<UpToDateInlineCompletions | undefined>('inlineCompletions', undefined);\n\tpublic readonly suggestWidgetInlineCompletions = disposableObservableValue<UpToDateInlineCompletions | undefined>('suggestWidgetInlineCompletions', undefined);\n\n\tprivate readonly _loggingEnabled = observableConfigValue('editor.inlineSuggest.logFetch', false, this._configurationService).recomputeInitiallyAndOnChange(this._store);\n\tprivate readonly _invalidationDelay = observableConfigValue<number>('editor.inlineSuggest.edits.experimental.invalidationDelay', 4000, this._configurationService).recomputeInitiallyAndOnChange(this._store);\n\n\tprivate readonly _structuredFetchLogger = this._register(this._instantiationService.createInstance(StructuredLogger.cast<\n\t\t{ kind: 'start'; requestId: number; context: unknown } & IRecordableEditorLogEntry\n\t\t| { kind: 'end'; error: any; durationMs: number; result: unknown; requestId: number } & IRecordableLogEntry\n\t>(),\n\t\t'editor.inlineSuggest.logFetch.commandId'\n\t));\n\n\tconstructor(\n\t\tprivate readonly _textModel: ITextModel,\n\t\tprivate readonly _versionId: IObservable<number | null>,\n\t\tprivate readonly _debounceValue: IFeatureDebounceInformation,\n\t\t@ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(this._textModel.onDidChangeContent((e) => {\n\t\t\tthis._updateOperation.clear();\n\n\t\t\tconst inlineCompletions = this.inlineCompletions.get();\n\t\t\tif (inlineCompletions) {\n\t\t\t\ttransaction(tx => {\n\t\t\t\t\tinlineCompletions.acceptTextModelChangeEvent(e, tx);\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate _log(entry:\n\t\t{ sourceId: string; kind: 'start'; requestId: number; context: unknown } & IRecordableEditorLogEntry\n\t\t| { sourceId: string; kind: 'end'; error: any; durationMs: number; result: unknown; requestId: number } & IRecordableLogEntry\n\t) {\n\t\tif (this._loggingEnabled.get()) {\n\t\t\tthis._logService.info(formatRecordableLogEntry(entry));\n\t\t}\n\t\tthis._structuredFetchLogger.log(entry);\n\t}\n\n\tpublic readonly loading = observableValue(this, false);\n\n\tpublic fetch(position: Position, context: InlineCompletionContext, activeInlineCompletion: InlineCompletionWithUpdatedRange | undefined): Promise<boolean> {\n\t\tconst request = new UpdateRequest(position, context, this._textModel.getVersionId());\n\n\t\tconst target = context.selectedSuggestionInfo ? this.suggestWidgetInlineCompletions : this.inlineCompletions;\n\n\t\tif (this._updateOperation.value?.request.satisfies(request)) {\n\t\t\treturn this._updateOperation.value.promise;\n\t\t} else if (target.get()?.request.satisfies(request)) {\n\t\t\treturn Promise.resolve(true);\n\t\t}\n\n\t\tthis.loading.set(true, undefined);\n\n\t\tconst updateOngoing = !!this._updateOperation.value;\n\t\tthis._updateOperation.clear();\n\n\t\tconst source = new CancellationTokenSource();\n\n\t\tconst promise = (async () => {\n\t\t\tconst shouldDebounce = updateOngoing || context.triggerKind === InlineCompletionTriggerKind.Automatic;\n\t\t\tif (shouldDebounce) {\n\t\t\t\t// This debounces the operation\n\t\t\t\tawait wait(this._debounceValue.get(this._textModel), source.token);\n\t\t\t}\n\n\t\t\tif (source.token.isCancellationRequested || this._store.isDisposed || this._textModel.getVersionId() !== request.versionId) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst requestId = InlineCompletionsSource._requestId++;\n\t\t\tif (this._loggingEnabled.get() || this._structuredFetchLogger.isEnabled.get()) {\n\t\t\t\tthis._log({ sourceId: 'InlineCompletions.fetch', kind: 'start', requestId, modelUri: this._textModel.uri.toString(), modelVersion: this._textModel.getVersionId(), context: { triggerKind: context.triggerKind }, time: Date.now() });\n\t\t\t}\n\n\t\t\tconst startTime = new Date();\n\t\t\tlet updatedCompletions: InlineCompletionProviderResult | undefined = undefined;\n\t\t\tlet error: any = undefined;\n\t\t\ttry {\n\t\t\t\tupdatedCompletions = await provideInlineCompletions(\n\t\t\t\t\tthis._languageFeaturesService.inlineCompletionsProvider,\n\t\t\t\t\tposition,\n\t\t\t\t\tthis._textModel,\n\t\t\t\t\tcontext,\n\t\t\t\t\tsource.token,\n\t\t\t\t\tthis._languageConfigurationService\n\t\t\t\t);\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\tif (this._loggingEnabled.get() || this._structuredFetchLogger.isEnabled.get()) {\n\t\t\t\t\tif (source.token.isCancellationRequested || this._store.isDisposed || this._textModel.getVersionId() !== request.versionId) {\n\t\t\t\t\t\terror = 'canceled';\n\t\t\t\t\t}\n\t\t\t\t\tconst result = updatedCompletions?.completions.map(c => ({\n\t\t\t\t\t\trange: c.range.toString(),\n\t\t\t\t\t\ttext: c.insertText,\n\t\t\t\t\t\tisInlineEdit: !!c.sourceInlineCompletion.isInlineEdit,\n\t\t\t\t\t\tsource: c.source.provider.groupId,\n\t\t\t\t\t}));\n\t\t\t\t\tthis._log({ sourceId: 'InlineCompletions.fetch', kind: 'end', requestId, durationMs: (Date.now() - startTime.getTime()), error, result, time: Date.now() });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (source.token.isCancellationRequested || this._store.isDisposed || this._textModel.getVersionId() !== request.versionId) {\n\t\t\t\tupdatedCompletions.dispose();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Reuse Inline Edit if possible\n\t\t\tif (activeInlineCompletion && activeInlineCompletion.isInlineEdit && (activeInlineCompletion.canBeReused(this._textModel, position) || updatedCompletions.has(activeInlineCompletion.inlineCompletion) /* Inline Edit wins over completions if it's already been shown*/)) {\n\t\t\t\tupdatedCompletions.dispose();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst endTime = new Date();\n\t\t\tthis._debounceValue.update(this._textModel, endTime.getTime() - startTime.getTime());\n\n\t\t\t// Reuse Inline Completion if possible\n\t\t\tconst completions = new UpToDateInlineCompletions(updatedCompletions, request, this._textModel, this._versionId, this._invalidationDelay);\n\t\t\tif (activeInlineCompletion && !activeInlineCompletion.isInlineEdit && activeInlineCompletion.canBeReused(this._textModel, position)) {\n\t\t\t\tconst asInlineCompletion = activeInlineCompletion.toInlineCompletion(undefined);\n\t\t\t\tif (!updatedCompletions.has(asInlineCompletion)) {\n\t\t\t\t\tcompletions.prepend(activeInlineCompletion.inlineCompletion, asInlineCompletion.range, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._updateOperation.clear();\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description Update completions with provider result */\n\t\t\t\ttarget.set(completions, tx);\n\t\t\t\tthis.loading.set(false, tx);\n\t\t\t});\n\n\t\t\treturn true;\n\t\t})();\n\n\t\tconst updateOperation = new UpdateOperation(request, source, promise);\n\t\tthis._updateOperation.value = updateOperation;\n\n\t\treturn promise;\n\t}\n\n\tpublic clear(tx: ITransaction): void {\n\t\tthis._updateOperation.clear();\n\t\tthis.inlineCompletions.set(undefined, tx);\n\t\tthis.suggestWidgetInlineCompletions.set(undefined, tx);\n\t}\n\n\tpublic clearSuggestWidgetInlineCompletions(tx: ITransaction): void {\n\t\tif (this._updateOperation.value?.request.context.selectedSuggestionInfo) {\n\t\t\tthis._updateOperation.clear();\n\t\t}\n\t\tthis.suggestWidgetInlineCompletions.set(undefined, tx);\n\t}\n\n\tpublic cancelUpdate(): void {\n\t\tthis._updateOperation.clear();\n\t}\n}\n\nfunction wait(ms: number, cancellationToken?: CancellationToken): Promise<void> {\n\treturn new Promise(resolve => {\n\t\tlet d: IDisposable | undefined = undefined;\n\t\tconst handle = setTimeout(() => {\n\t\t\tif (d) { d.dispose(); }\n\t\t\tresolve();\n\t\t}, ms);\n\t\tif (cancellationToken) {\n\t\t\td = cancellationToken.onCancellationRequested(() => {\n\t\t\t\tclearTimeout(handle);\n\t\t\t\tif (d) { d.dispose(); }\n\t\t\t\tresolve();\n\t\t\t});\n\t\t}\n\t});\n}\n\nclass UpdateRequest {\n\tconstructor(\n\t\tpublic readonly position: Position,\n\t\tpublic readonly context: InlineCompletionContext,\n\t\tpublic readonly versionId: number,\n\t) {\n\t}\n\n\tpublic satisfies(other: UpdateRequest): boolean {\n\t\treturn this.position.equals(other.position)\n\t\t\t&& equalsIfDefined(this.context.selectedSuggestionInfo, other.context.selectedSuggestionInfo, itemEquals())\n\t\t\t&& (other.context.triggerKind === InlineCompletionTriggerKind.Automatic\n\t\t\t\t|| this.context.triggerKind === InlineCompletionTriggerKind.Explicit)\n\t\t\t&& this.versionId === other.versionId;\n\t}\n\n\tpublic get isExplicitRequest() {\n\t\treturn this.context.triggerKind === InlineCompletionTriggerKind.Explicit;\n\t}\n}\n\nclass UpdateOperation implements IDisposable {\n\tconstructor(\n\t\tpublic readonly request: UpdateRequest,\n\t\tpublic readonly cancellationTokenSource: CancellationTokenSource,\n\t\tpublic readonly promise: Promise<boolean>,\n\t) {\n\t}\n\n\tdispose() {\n\t\tthis.cancellationTokenSource.cancel();\n\t}\n}\n\nexport class UpToDateInlineCompletions implements IDisposable {\n\tprivate readonly _inlineCompletions: InlineCompletionWithUpdatedRange[];\n\tpublic get inlineCompletions(): ReadonlyArray<InlineCompletionWithUpdatedRange> { return this._inlineCompletions; }\n\n\tprivate _refCount = 1;\n\tprivate readonly _prependedInlineCompletionItems: InlineCompletionItem[] = [];\n\n\tconstructor(\n\t\tprivate readonly inlineCompletionProviderResult: InlineCompletionProviderResult,\n\t\tpublic readonly request: UpdateRequest,\n\t\tprivate readonly _textModel: ITextModel,\n\t\tprivate readonly _versionId: IObservable<number | null>,\n\t\tprivate readonly _invalidationDelay: IObservable<number>,\n\t) {\n\t\tconst ids = _textModel.deltaDecorations([], inlineCompletionProviderResult.completions.map(i => ({\n\t\t\trange: i.range,\n\t\t\toptions: {\n\t\t\t\tdescription: 'inline-completion-tracking-range'\n\t\t\t},\n\t\t})));\n\n\t\tthis._inlineCompletions = inlineCompletionProviderResult.completions.map(\n\t\t\t(i, index) => new InlineCompletionWithUpdatedRange(i, ids[index], this._textModel, this._versionId, this._invalidationDelay, this.request)\n\t\t);\n\t}\n\n\tpublic acceptTextModelChangeEvent(e: IModelContentChangedEvent, tx: ITransaction) {\n\t\tfor (const inlineCompletion of this._inlineCompletions) {\n\t\t\tinlineCompletion.acceptTextModelChangeEvent(e, tx);\n\t\t}\n\t}\n\n\tpublic clone(): this {\n\t\tthis._refCount++;\n\t\treturn this;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._refCount--;\n\t\tif (this._refCount === 0) {\n\t\t\tsetTimeout(() => {\n\t\t\t\t// To fix https://github.com/microsoft/vscode/issues/188348\n\t\t\t\tif (!this._textModel.isDisposed()) {\n\t\t\t\t\t// This is just cleanup. It's ok if it happens with a delay.\n\t\t\t\t\tthis._textModel.deltaDecorations(this._inlineCompletions.map(i => i.decorationId), []);\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t\tthis.inlineCompletionProviderResult.dispose();\n\t\t\tfor (const i of this._prependedInlineCompletionItems) {\n\t\t\t\ti.source.removeRef();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic prepend(inlineCompletion: InlineCompletionItem, range: Range, addRefToSource: boolean): void {\n\t\tif (addRefToSource) {\n\t\t\tinlineCompletion.source.addRef();\n\t\t}\n\n\t\tconst id = this._textModel.deltaDecorations([], [{\n\t\t\trange,\n\t\t\toptions: {\n\t\t\t\tdescription: 'inline-completion-tracking-range'\n\t\t\t},\n\t\t}])[0];\n\t\tthis._inlineCompletions.unshift(new InlineCompletionWithUpdatedRange(inlineCompletion, id, this._textModel, this._versionId, this._invalidationDelay, this.request));\n\t\tthis._prependedInlineCompletionItems.push(inlineCompletion);\n\t}\n}\n\nexport class InlineCompletionWithUpdatedRange {\n\tpublic readonly semanticId = JSON.stringify([\n\t\tthis.inlineCompletion.filterText,\n\t\tthis.inlineCompletion.insertText,\n\t\tthis.inlineCompletion.range.getStartPosition().toString()\n\t]);\n\n\tpublic get forwardStable() {\n\t\treturn this.source.inlineCompletions.enableForwardStability ?? false;\n\t}\n\n\tprivate readonly _updatedRange = derivedOpts<Range | null>({ owner: this, equalsFn: Range.equalsRange }, reader => {\n\t\tif (this._inlineEdit.read(reader)) {\n\t\t\tconst edit = this.toSingleTextEdit(reader);\n\t\t\treturn (edit.isEmpty ? null : edit.range);\n\t\t} else {\n\t\t\tthis._modelVersion.read(reader);\n\t\t\treturn this._textModel.getDecorationRange(this.decorationId);\n\t\t}\n\t});\n\n\t/**\n\t * This will be null for ghost text completions\n\t */\n\tprivate _inlineEdit: ISettableObservable<OffsetEdit | null>;\n\tpublic get inlineEdit(): IObservable<OffsetEdit | null> { return this._inlineEdit; }\n\n\tpublic get source() { return this.inlineCompletion.source; }\n\tpublic get sourceInlineCompletion() { return this.inlineCompletion.sourceInlineCompletion; }\n\tpublic get isInlineEdit() { return this.inlineCompletion.sourceInlineCompletion.isInlineEdit; }\n\n\tprivate _invalidationTime: number | undefined = Date.now() + this._invalidationDelay.get();\n\n\tprivate _lastChangePartOfInlineEdit = false;\n\n\tconstructor(\n\t\tpublic readonly inlineCompletion: InlineCompletionItem,\n\t\tpublic readonly decorationId: string,\n\t\tprivate readonly _textModel: ITextModel,\n\t\tprivate readonly _modelVersion: IObservable<number | null>,\n\t\tprivate readonly _invalidationDelay: IObservable<number>,\n\t\tpublic readonly request: UpdateRequest,\n\t) {\n\t\tconst inlineCompletions = this.inlineCompletion.source.inlineCompletions.items;\n\t\tif (inlineCompletions.length > 0 && inlineCompletions[inlineCompletions.length - 1].isInlineEdit) {\n\t\t\tthis._inlineEdit = observableValue(this, this._toIndividualEdits(this.inlineCompletion.range, this.inlineCompletion.insertText));\n\t\t} else {\n\t\t\tthis._inlineEdit = observableValue(this, null);\n\t\t}\n\t}\n\n\tprivate _toIndividualEdits(editRange: Range, _replaceText: string): OffsetEdit {\n\t\tconst eol = this._textModel.getEOL();\n\t\tconst editOriginalText = this._textModel.getValueInRange(editRange);\n\t\tconst editReplaceText = _replaceText.replace(/\\r\\n|\\r|\\n/g, eol);\n\n\t\tconst diffAlgorithm = linesDiffComputers.getDefault();\n\t\tconst lineDiffs = diffAlgorithm.computeDiff(\n\t\t\tsplitLines(editOriginalText),\n\t\t\tsplitLines(editReplaceText),\n\t\t\t{\n\t\t\t\tignoreTrimWhitespace: false,\n\t\t\t\tcomputeMoves: false,\n\t\t\t\textendToSubwords: true,\n\t\t\t\tmaxComputationTimeMs: 500,\n\t\t\t}\n\t\t);\n\n\t\tconst innerChanges = lineDiffs.changes.flatMap(c => c.innerChanges ?? []);\n\t\tif (innerChanges.length === 0) {\n\t\t\tconst startOffset = this._textModel.getOffsetAt(editRange.getStartPosition());\n\t\t\treturn new OffsetEdit(\n\t\t\t\t[new SingleOffsetEdit(OffsetRange.ofStartAndLength(startOffset, editOriginalText.length), editReplaceText)]\n\t\t\t);\n\t\t}\n\n\t\tfunction addRangeToPos(pos: Position, range: Range): Range {\n\t\t\tconst start = TextLength.fromPosition(range.getStartPosition());\n\t\t\treturn TextLength.ofRange(range).createRange(start.addToPosition(pos));\n\t\t}\n\n\t\tconst modifiedText = new StringText(editReplaceText);\n\n\t\treturn new OffsetEdit(\n\t\t\tinnerChanges.map(c => {\n\t\t\t\tconst range = addRangeToPos(editRange.getStartPosition(), c.originalRange);\n\t\t\t\tconst startOffset = this._textModel.getOffsetAt(range.getStartPosition());\n\t\t\t\tconst endOffset = this._textModel.getOffsetAt(range.getEndPosition());\n\t\t\t\tconst originalRange = OffsetRange.ofStartAndLength(startOffset, endOffset - startOffset);\n\n\t\t\t\t// TODO: EOL are not properly trimmed by the diffAlgorithm #12680\n\t\t\t\tconst replaceText = modifiedText.getValueOfRange(c.modifiedRange);\n\t\t\t\tconst oldText = this._textModel.getValueInRange(range);\n\t\t\t\tif (replaceText.endsWith(eol) && oldText.endsWith(eol)) {\n\t\t\t\t\treturn new SingleOffsetEdit(originalRange.deltaEnd(-eol.length), replaceText.slice(0, -eol.length));\n\t\t\t\t}\n\n\t\t\t\treturn new SingleOffsetEdit(originalRange, replaceText);\n\t\t\t})\n\t\t);\n\t}\n\n\tpublic acceptTextModelChangeEvent(e: IModelContentChangedEvent, tx: ITransaction): void {\n\t\tthis._lastChangePartOfInlineEdit = false;\n\n\t\tconst offsetEdit = this._inlineEdit.get();\n\t\tif (!offsetEdit) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst editUpdates = offsetEdit.edits.map(edit => acceptTextModelChange(edit, e.changes));\n\t\tconst newEdits = editUpdates.filter(({ changeType }) => changeType !== 'fullyAccepted').map(({ edit }) => edit);\n\n\t\tconst emptyEdit = newEdits.find(edit => edit.isEmpty);\n\t\tif (emptyEdit || newEdits.length === 0) {\n\t\t\t// Either a change collided with one of our edits, so we will have to drop the completion\n\t\t\t// Or the completion has been typed by the user\n\t\t\tthis._inlineEdit.set(new OffsetEdit([emptyEdit ?? new SingleOffsetEdit(new OffsetRange(0, 0), '')]), tx);\n\t\t\treturn;\n\t\t}\n\n\t\tconst changePartiallyAcceptsEdit = editUpdates.some(({ changeType }) => changeType === 'partiallyAccepted' || changeType === 'fullyAccepted');\n\n\t\tif (changePartiallyAcceptsEdit) {\n\t\t\tthis._invalidationTime = undefined;\n\t\t}\n\t\tif (this._invalidationTime && this._invalidationTime < Date.now()) {\n\t\t\t// The completion has been shown for a while and the user\n\t\t\t// has been working on a different part of the document, so invalidate it\n\t\t\tthis._inlineEdit.set(new OffsetEdit([new SingleOffsetEdit(new OffsetRange(0, 0), '')]), tx);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lastChangePartOfInlineEdit = changePartiallyAcceptsEdit;\n\t\tthis._inlineEdit.set(new OffsetEdit(newEdits), tx);\n\n\t\tfunction acceptTextModelChange(edit: SingleOffsetEdit, changes: readonly IModelContentChange[]): { edit: SingleOffsetEdit; changeType: 'move' | 'partiallyAccepted' | 'fullyAccepted' } {\n\t\t\tlet start = edit.replaceRange.start;\n\t\t\tlet end = edit.replaceRange.endExclusive;\n\t\t\tlet newText = edit.newText;\n\t\t\tlet changeType: 'move' | 'partiallyAccepted' | 'fullyAccepted' = 'move';\n\t\t\tfor (let i = changes.length - 1; i >= 0; i--) {\n\t\t\t\tconst change = changes[i];\n\n\t\t\t\t// Edit is an insertion: user inserted text at the start of the completion\n\t\t\t\tif (edit.replaceRange.isEmpty && change.rangeLength === 0 && change.rangeOffset === start && newText.startsWith(change.text)) {\n\t\t\t\t\tstart += change.text.length;\n\t\t\t\t\tend = Math.max(start, end);\n\t\t\t\t\tnewText = newText.substring(change.text.length);\n\t\t\t\t\tchangeType = newText.length === 0 ? 'fullyAccepted' : 'partiallyAccepted';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Edit is a deletion: user deleted text inside the deletion range\n\t\t\t\tif (!edit.replaceRange.isEmpty && change.text.length === 0 && change.rangeOffset >= start && change.rangeOffset + change.rangeLength <= end) {\n\t\t\t\t\tend -= change.rangeLength;\n\t\t\t\t\tchangeType = start === end ? 'fullyAccepted' : 'partiallyAccepted';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (change.rangeOffset > end) {\n\t\t\t\t\t// the change happens after the completion range\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (change.rangeOffset + change.rangeLength < start) {\n\t\t\t\t\t// the change happens before the completion range\n\t\t\t\t\tstart += change.text.length - change.rangeLength;\n\t\t\t\t\tend += change.text.length - change.rangeLength;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// The change intersects the completion, so we will have to drop the completion\n\t\t\t\tstart = change.rangeOffset;\n\t\t\t\tend = change.rangeOffset;\n\t\t\t\tnewText = '';\n\t\t\t}\n\t\t\treturn { edit: new SingleOffsetEdit(new OffsetRange(start, end), newText), changeType };\n\t\t}\n\t}\n\n\tpublic toInlineCompletion(reader: IReader | undefined): InlineCompletionItem {\n\t\tconst singleTextEdit = this.toSingleTextEdit(reader);\n\t\treturn this.inlineCompletion.withRangeInsertTextAndFilterText(singleTextEdit.range, singleTextEdit.text, singleTextEdit.text);\n\t}\n\n\tpublic toSingleTextEdit(reader: IReader | undefined): SingleTextEdit {\n\t\tthis._modelVersion.read(reader);\n\t\tconst offsetEdit = this._inlineEdit.read(reader);\n\t\tif (!offsetEdit) {\n\t\t\treturn new SingleTextEdit(this._updatedRange.read(reader) ?? emptyRange, this.inlineCompletion.insertText);\n\t\t}\n\n\t\tconst startOffset = offsetEdit.edits[0].replaceRange.start;\n\t\tconst endOffset = offsetEdit.edits[offsetEdit.edits.length - 1].replaceRange.endExclusive;\n\t\tconst overallOffsetRange = new OffsetRange(startOffset, endOffset);\n\t\tconst overallLnColRange = Range.fromPositions(\n\t\t\tthis._textModel.getPositionAt(overallOffsetRange.start),\n\t\t\tthis._textModel.getPositionAt(overallOffsetRange.endExclusive)\n\t\t);\n\t\tlet text = this._textModel.getValueInRange(overallLnColRange);\n\t\tfor (let i = offsetEdit.edits.length - 1; i >= 0; i--) {\n\t\t\tconst edit = offsetEdit.edits[i];\n\t\t\tconst relativeStartOffset = edit.replaceRange.start - startOffset;\n\t\t\tconst relativeEndOffset = edit.replaceRange.endExclusive - startOffset;\n\t\t\ttext = text.substring(0, relativeStartOffset) + edit.newText + text.substring(relativeEndOffset);\n\t\t}\n\t\treturn new SingleTextEdit(overallLnColRange, text);\n\t}\n\n\tpublic isVisible(model: ITextModel, cursorPosition: Position, reader: IReader | undefined): boolean {\n\t\tconst minimizedReplacement = singleTextRemoveCommonPrefix(this._toFilterTextReplacement(reader), model);\n\t\tconst updatedRange = this._updatedRange.read(reader);\n\t\tif (\n\t\t\t!updatedRange\n\t\t\t|| !this.inlineCompletion.range.getStartPosition().equals(updatedRange.getStartPosition())\n\t\t\t|| cursorPosition.lineNumber !== minimizedReplacement.range.startLineNumber\n\t\t\t|| minimizedReplacement.isEmpty // if the completion is empty after removing the common prefix of the completion and the model, the completion item would not be visible\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We might consider comparing by .toLowerText, but this requires GhostTextReplacement\n\t\tconst originalValue = model.getValueInRange(minimizedReplacement.range, EndOfLinePreference.LF);\n\t\tconst filterText = minimizedReplacement.text;\n\n\t\tconst cursorPosIndex = Math.max(0, cursorPosition.column - minimizedReplacement.range.startColumn);\n\n\t\tlet filterTextBefore = filterText.substring(0, cursorPosIndex);\n\t\tlet filterTextAfter = filterText.substring(cursorPosIndex);\n\n\t\tlet originalValueBefore = originalValue.substring(0, cursorPosIndex);\n\t\tlet originalValueAfter = originalValue.substring(cursorPosIndex);\n\n\t\tconst originalValueIndent = model.getLineIndentColumn(minimizedReplacement.range.startLineNumber);\n\t\tif (minimizedReplacement.range.startColumn <= originalValueIndent) {\n\t\t\t// Remove indentation\n\t\t\toriginalValueBefore = originalValueBefore.trimStart();\n\t\t\tif (originalValueBefore.length === 0) {\n\t\t\t\toriginalValueAfter = originalValueAfter.trimStart();\n\t\t\t}\n\t\t\tfilterTextBefore = filterTextBefore.trimStart();\n\t\t\tif (filterTextBefore.length === 0) {\n\t\t\t\tfilterTextAfter = filterTextAfter.trimStart();\n\t\t\t}\n\t\t}\n\n\t\treturn filterTextBefore.startsWith(originalValueBefore)\n\t\t\t&& !!matchesSubString(originalValueAfter, filterTextAfter);\n\t}\n\n\tpublic canBeReused(model: ITextModel, position: Position): boolean {\n\t\tconst inlineEdit = this._inlineEdit.get();\n\t\tif (inlineEdit !== null) {\n\t\t\treturn model === this._textModel\n\t\t\t\t&& !inlineEdit.isEmpty\n\t\t\t\t&& this._lastChangePartOfInlineEdit;\n\t\t}\n\n\t\tconst updatedRange = this._updatedRange.read(undefined);\n\t\tconst result = !!updatedRange\n\t\t\t&& updatedRange.containsPosition(position)\n\t\t\t&& this.isVisible(model, position, undefined)\n\t\t\t&& TextLength.ofRange(updatedRange).isGreaterThanOrEqualTo(TextLength.ofRange(this.inlineCompletion.range));\n\t\treturn result;\n\t}\n\n\tprivate _toFilterTextReplacement(reader: IReader | undefined): SingleTextEdit {\n\t\tconst inlineCompletion = this.toInlineCompletion(reader);\n\t\treturn new SingleTextEdit(inlineCompletion.range, inlineCompletion.filterText);\n\t}\n}\n\nconst emptyRange = new Range(1, 1, 1, 1);\n\ninterface IRecordableLogEntry {\n\tsourceId: string;\n\ttime: number;\n}\n\nexport interface IRecordableEditorLogEntry extends IRecordableLogEntry {\n\tmodelUri: string;\n\tmodelVersion: number;\n}\n\n/**\n * The sourceLabel must not contain '@'!\n*/\nexport function formatRecordableLogEntry<T extends IRecordableLogEntry>(entry: T): string {\n\treturn entry.sourceId + ' @@ ' + JSON.stringify({ ...entry, sourceId: undefined });\n}\n\nexport class StructuredLogger<T extends IRecordableLogEntry> extends Disposable {\n\tpublic static cast<T extends IRecordableLogEntry>(): typeof StructuredLogger<T> {\n\t\treturn this as typeof StructuredLogger<T>;\n\t}\n\n\tprivate readonly _contextKeyValue = observableContextKey<string>(this._contextKey, this._contextKeyService).recomputeInitiallyAndOnChange(this._store);\n\n\tconstructor(\n\t\tprivate readonly _contextKey: string,\n\t\t@IContextKeyService private readonly _contextKeyService: IContextKeyService,\n\t\t@ICommandService private readonly _commandService: ICommandService,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic readonly isEnabled = this._contextKeyValue.map(v => v !== undefined);\n\n\tpublic log(data: T): boolean {\n\t\tconst commandId = this._contextKeyValue.get();\n\t\tif (!commandId) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._commandService.executeCommand(commandId, data);\n\t\treturn true;\n\t}\n}\n\nexport function observableContextKey<T>(key: string, contextKeyService: IContextKeyService): IObservable<T | undefined> {\n\treturn observableFromEvent(contextKeyService.onDidChangeContext, () => contextKeyService.getContextKeyValue<T>(key));\n}\n"]}