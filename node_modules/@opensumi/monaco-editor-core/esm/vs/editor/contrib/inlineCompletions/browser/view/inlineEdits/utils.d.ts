import { DisposableStore, IDisposable } from '../../../../../../base/common/lifecycle.js';
import { IObservable, IReader } from '../../../../../../base/common/observable.js';
import { MenuEntryActionViewItem } from '../../../../../../platform/actions/browser/menuEntryActionViewItem.js';
import { ICodeEditor } from '../../../../../browser/editorBrowser.js';
import { ObservableCodeEditor } from '../../../../../browser/observableCodeEditor.js';
import { Point } from '../../../../../browser/point.js';
import { Rect } from '../../../../../browser/rect.js';
import { LineRange } from '../../../../../common/core/lineRange.js';
import { Position } from '../../../../../common/core/position.js';
import { Range } from '../../../../../common/core/range.js';
import { TextEdit } from '../../../../../common/core/textEdit.js';
import { RangeMapping } from '../../../../../common/diff/rangeMapping.js';
export declare function maxContentWidthInRange(editor: ObservableCodeEditor, range: LineRange, reader: IReader | undefined): number;
export declare function getOffsetForPos(editor: ObservableCodeEditor, pos: Position, reader: IReader): number;
export declare function getPrefixTrim(diffRanges: Range[], originalLinesRange: LineRange, modifiedLines: string[], editor: ICodeEditor): {
    prefixTrim: number;
    prefixLeftOffset: number;
};
export declare class StatusBarViewItem extends MenuEntryActionViewItem {
    protected readonly _updateLabelListener: IDisposable;
    protected updateLabel(): void;
    protected updateTooltip(): void;
}
export declare function applyEditToModifiedRangeMappings(rangeMapping: RangeMapping[], edit: TextEdit): RangeMapping[];
export declare function classNames(...classes: (string | false | undefined | null)[]): string;
export declare function createReindentEdit(text: string, range: LineRange): TextEdit;
export declare class PathBuilder {
    private _data;
    moveTo(point: Point): this;
    lineTo(point: Point): this;
    curveTo(cp: Point, to: Point): this;
    curveTo2(cp1: Point, cp2: Point, to: Point): this;
    build(): string;
}
export declare function createRectangle(layout: {
    topLeft: Point;
    width: number;
    height: number;
}, padding: number | {
    top: number;
    right: number;
    bottom: number;
    left: number;
}, borderRadius: number | {
    topLeft: number;
    topRight: number;
    bottomLeft: number;
    bottomRight: number;
}, options?: {
    hideLeft?: boolean;
    hideRight?: boolean;
    hideTop?: boolean;
    hideBottom?: boolean;
}): string;
type Value<T> = T | IObservable<T>;
type ValueOrList<T> = Value<T> | ValueOrList<T>[];
type ValueOrList2<T> = ValueOrList<T> | ValueOrList<ValueOrList<T>>;
type Element = HTMLElement | SVGElement;
type SVGElementTagNameMap2 = {
    svg: SVGElement & {
        width: number;
        height: number;
        transform: string;
        viewBox: string;
        fill: string;
    };
    path: SVGElement & {
        d: string;
        stroke: string;
        fill: string;
    };
    linearGradient: SVGElement & {
        id: string;
        x1: string | number;
        x2: string | number;
    };
    stop: SVGElement & {
        offset: string;
    };
    rect: SVGElement & {
        x: number;
        y: number;
        width: number;
        height: number;
        fill: string;
    };
    defs: SVGElement;
};
type DomTagCreateFn<TMap extends Record<string, any>> = <TTag extends keyof TMap>(tag: TTag, attributes: ElementAttributeKeys<TMap[TTag]> & {
    class?: ValueOrList<string | false | undefined>;
    ref?: IRef<TMap[TTag]>;
}, children?: ChildNode) => ObserverNode<TMap[TTag]>;
type DomCreateFn<TAttributes, TResult extends Element> = (attributes: ElementAttributeKeys<TAttributes> & {
    class?: ValueOrList<string | false | undefined>;
    ref?: IRef<TResult>;
}, children?: ChildNode) => ObserverNode<TResult>;
export type ChildNode = ValueOrList2<Element | string | ObserverNode | undefined>;
export declare namespace n {
    const div: DomCreateFn<HTMLDivElement, HTMLDivElement>;
    const elem: DomTagCreateFn<HTMLElementTagNameMap>;
    const svg: DomCreateFn<SVGElementTagNameMap2['svg'], SVGElement>;
    const svgElem: DomTagCreateFn<SVGElementTagNameMap2>;
    function ref<T = Element>(): IRefWithVal<T>;
}
export type IRef<T> = (value: T) => void;
export interface IRefWithVal<T> extends IRef<T> {
    readonly element: T;
}
export declare abstract class ObserverNode<T extends Element = Element> {
    private readonly _deriveds;
    protected readonly _element: T;
    constructor(tag: string, ref: IRef<T> | undefined, ns: string | undefined, className: ValueOrList<string | undefined | false> | undefined, attributes: ElementAttributeKeys<T>, children: ChildNode);
    readEffect(reader: IReader | undefined): void;
    keepUpdated(store: DisposableStore): ObserverNodeWithElement<T>;
    /**
     * Creates a live element that will keep the element updated as long as the returned object is not disposed.
    */
    toDisposableLiveElement(): LiveElement<T>;
}
export declare class LiveElement<T extends Element = HTMLElement> {
    readonly element: T;
    private readonly _disposable;
    constructor(element: T, _disposable: IDisposable);
    dispose(): void;
}
export declare class ObserverNodeWithElement<T extends Element = Element> extends ObserverNode<T> {
    get element(): T;
    getIsHovered(store: DisposableStore): IObservable<boolean>;
}
type ElementAttributeKeys<T> = Partial<{
    [K in keyof T]: T[K] extends Function ? never : T[K] extends object ? ElementAttributeKeys<T[K]> : Value<number | T[K] | undefined | null>;
}>;
type RemoveFalsy<T> = T extends false | undefined | null ? never : T;
type Falsy<T> = T extends false | undefined | null ? T : never;
export declare function mapOutFalsy<T>(obs: IObservable<T>): IObservable<IObservable<RemoveFalsy<T>> | Falsy<T>>;
export declare function rectToProps(fn: (reader: IReader) => Rect): {
    left: IObservable<number>;
    top: IObservable<number>;
    width: IObservable<number>;
    height: IObservable<number>;
};
export type FirstFnArg<T> = T extends (arg: infer U) => any ? U : never;
export {};
