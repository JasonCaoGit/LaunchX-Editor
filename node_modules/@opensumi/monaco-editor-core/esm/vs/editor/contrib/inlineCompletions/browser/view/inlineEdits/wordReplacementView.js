/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { Disposable, toDisposable } from '../../../../../../base/common/lifecycle.js';
import { constObservable, derived, mapObservableArrayCached } from '../../../../../../base/common/observable.js';
import { editorHoverStatusBarBackground } from '../../../../../../platform/theme/common/colorRegistry.js';
import { registerColor, transparent } from '../../../../../../platform/theme/common/colorUtils.js';
import { Rect } from '../../../../../browser/rect.js';
import { LineSource, renderLines, RenderOptions } from '../../../../../browser/widget/diffEditor/components/diffEditorViewZones/renderLines.js';
import { SingleOffsetEdit } from '../../../../../common/core/offsetEdit.js';
import { OffsetRange } from '../../../../../common/core/offsetRange.js';
import { ILanguageService } from '../../../../../common/languages/language.js';
import { LineTokens } from '../../../../../common/tokens/lineTokens.js';
import { TokenArray } from '../../../../../common/tokens/tokenArray.js';
import { getPrefixTrim, mapOutFalsy, n, rectToProps } from './utils.js';
import { localize } from '../../../../../../nls.js';
import { Range } from '../../../../../common/core/range.js';
import { InlineDecoration } from '../../../../../common/viewModel.js';
import { $ } from '../../../../../../base/browser/dom.js';
import { observableValue } from '../../../../../../base/common/observableInternal/base.js';
export const transparentHoverBackground = registerColor('inlineEdit.wordReplacementView.background', {
    light: transparent(editorHoverStatusBarBackground, 0.1),
    dark: transparent(editorHoverStatusBarBackground, 0.1),
    hcLight: transparent(editorHoverStatusBarBackground, 0.1),
    hcDark: transparent(editorHoverStatusBarBackground, 0.1),
}, localize("vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/wordReplacementView",0, 'Background color for the inline edit word replacement view.'));
let WordReplacementView = class WordReplacementView extends Disposable {
    static { this.MAX_LENGTH = 100; }
    constructor(_editor, 
    /** Must be single-line in both sides */
    _edit, _innerEdits, _languageService) {
        super();
        this._editor = _editor;
        this._edit = _edit;
        this._innerEdits = _innerEdits;
        this._languageService = _languageService;
        this._start = this._editor.observePosition(constObservable(this._edit.range.getStartPosition()), this._store);
        this._end = this._editor.observePosition(constObservable(this._edit.range.getEndPosition()), this._store);
        this._line = document.createElement('div');
        this._text = derived(reader => {
            const tm = this._editor.model.get();
            const origLine = tm.getLineContent(this._edit.range.startLineNumber);
            const edit = SingleOffsetEdit.replace(new OffsetRange(this._edit.range.startColumn - 1, this._edit.range.endColumn - 1), this._edit.text);
            const lineToTokenize = edit.apply(origLine);
            const t = tm.tokenization.tokenizeLinesAt(this._edit.range.startLineNumber, [lineToTokenize])?.[0];
            let tokens;
            if (t) {
                tokens = TokenArray.fromLineTokens(t).slice(edit.getRangeAfterApply()).toLineTokens(this._edit.text, this._languageService.languageIdCodec);
            }
            else {
                tokens = LineTokens.createEmpty(this._edit.text, this._languageService.languageIdCodec);
            }
            renderLines(new LineSource([tokens]), RenderOptions.fromEditor(this._editor.editor).withSetWidth(false), [], this._line, true);
        });
        this._editLocations = mapObservableArrayCached(this, constObservable(this._innerEdits), (edit, store) => {
            const start = this._editor.observePosition(constObservable(edit.range.getStartPosition()), store);
            const end = this._editor.observePosition(constObservable(edit.range.getEndPosition()), store);
            return { start, end, edit };
        }).recomputeInitiallyAndOnChange(this._store);
        this._layout = derived(this, reader => {
            this._text.read(reader);
            const widgetStart = this._start.read(reader);
            const widgetEnd = this._end.read(reader);
            if (!widgetStart || !widgetEnd || widgetStart.x > widgetEnd.x) {
                return undefined;
            }
            const contentLeft = this._editor.layoutInfoContentLeft.read(reader);
            const lineHeight = this._editor.getOption(68 /* EditorOption.lineHeight */).read(reader);
            const scrollLeft = this._editor.scrollLeft.read(reader);
            const w = this._editor.getOption(52 /* EditorOption.fontInfo */).read(reader).typicalHalfwidthCharacterWidth;
            const modifiedLeftOffset = 20;
            const modifiedTopOffset = 5;
            const PADDING = 4;
            const originalLine = Rect.fromLeftTopWidthHeight(widgetStart.x + contentLeft - scrollLeft, widgetStart.y, widgetEnd.x - widgetStart.x, lineHeight);
            const modifiedLine = Rect.fromLeftTopWidthHeight(originalLine.left + modifiedLeftOffset, originalLine.top + lineHeight + modifiedTopOffset, this._edit.text.length * w + 5, originalLine.height);
            const background = Rect.hull([originalLine, modifiedLine]).withMargin(PADDING);
            let textLengthDelta = 0;
            const editLocations = this._editLocations.read(reader);
            const innerEdits = [];
            for (const editLocation of editLocations) {
                const editStart = editLocation.start.read(reader);
                const editEnd = editLocation.end.read(reader);
                const edit = editLocation.edit;
                if (!editStart || !editEnd || editStart.x > editEnd.x) {
                    return;
                }
                const original = Rect.fromLeftTopWidthHeight(editStart.x + contentLeft - scrollLeft, editStart.y, editEnd.x - editStart.x, lineHeight);
                const modified = Rect.fromLeftTopWidthHeight(original.left + modifiedLeftOffset + textLengthDelta * w, original.top + lineHeight + modifiedTopOffset, edit.text.length * w + 5, original.height);
                textLengthDelta += edit.text.length - (edit.range.endColumn - edit.range.startColumn);
                innerEdits.push({ original, modified });
            }
            const lowerBackground = background.intersectVertical(new OffsetRange(originalLine.bottom, Number.MAX_SAFE_INTEGER));
            const lowerText = new Rect(lowerBackground.left + modifiedLeftOffset + 6, lowerBackground.top + modifiedTopOffset, lowerBackground.right, lowerBackground.bottom); // TODO: left seems slightly off? zooming?
            return {
                originalLine,
                modifiedLine,
                background,
                innerEdits,
                lowerBackground,
                lowerText,
                padding: PADDING
            };
        });
        this._div = n.div({
            class: 'word-replacement',
        }, [
            derived(reader => {
                const layout = mapOutFalsy(this._layout).read(reader);
                if (!layout) {
                    return [];
                }
                const layoutProps = layout.read(reader);
                const scrollLeft = this._editor.scrollLeft.read(reader);
                let contentLeft = this._editor.layoutInfoContentLeft.read(reader);
                let contentWidth = this._editor.contentWidth.read(reader);
                const contentHeight = this._editor.editor.getContentHeight();
                if (scrollLeft === 0) {
                    contentLeft -= layoutProps.padding;
                    contentWidth += layoutProps.padding;
                }
                const edits = layoutProps.innerEdits.map(edit => ({ modified: edit.modified.moveLeft(contentLeft), original: edit.original.moveLeft(contentLeft) }));
                return [
                    n.div({
                        style: {
                            position: 'absolute',
                            top: 0,
                            left: contentLeft,
                            width: contentWidth,
                            height: contentHeight,
                            overflow: 'hidden',
                            pointerEvents: 'none',
                        }
                    }, [
                        n.div({
                            style: {
                                position: 'absolute',
                                ...rectToProps(reader => layout.read(reader).lowerBackground.moveLeft(contentLeft)),
                                borderRadius: '4px',
                                background: 'var(--vscode-editor-background)',
                                boxShadow: 'var(--vscode-scrollbar-shadow) 0 6px 6px -6px'
                            },
                        }, []),
                        n.div({
                            style: {
                                position: 'absolute',
                                padding: '0px',
                                boxSizing: 'border-box',
                                ...rectToProps(reader => layout.read(reader).lowerText.moveLeft(contentLeft)),
                                fontFamily: this._editor.getOption(51 /* EditorOption.fontFamily */),
                                fontSize: this._editor.getOption(54 /* EditorOption.fontSize */),
                                fontWeight: this._editor.getOption(55 /* EditorOption.fontWeight */),
                                pointerEvents: 'none',
                            }
                        }, [this._line]),
                        ...edits.map(edit => n.div({
                            style: {
                                position: 'absolute',
                                top: edit.modified.top,
                                left: edit.modified.left,
                                width: edit.modified.width,
                                height: edit.modified.height,
                                borderRadius: '4px',
                                background: 'var(--vscode-inlineEdit-modifiedChangedTextBackground)',
                                pointerEvents: 'none',
                            }
                        }), []),
                        ...edits.map(edit => n.div({
                            style: {
                                position: 'absolute',
                                top: edit.original.top,
                                left: edit.original.left,
                                width: edit.original.width,
                                height: edit.original.height,
                                borderRadius: '4px',
                                boxSizing: 'border-box',
                                background: 'var(--vscode-inlineEdit-originalChangedTextBackground)',
                                pointerEvents: 'none',
                            }
                        }, [])),
                        n.div({
                            style: {
                                position: 'absolute',
                                ...rectToProps(reader => layout.read(reader).background.moveLeft(contentLeft)),
                                borderRadius: '4px',
                                border: '1px solid var(--vscode-editorHoverWidget-border)',
                                //background: 'rgba(122, 122, 122, 0.12)', looks better
                                background: 'var(--vscode-inlineEdit-wordReplacementView-background)',
                                pointerEvents: 'none',
                                boxSizing: 'border-box',
                            }
                        }, []),
                        n.svg({
                            width: 11,
                            height: 13,
                            viewBox: '0 0 11 13',
                            fill: 'none',
                            style: {
                                position: 'absolute',
                                left: derived(reader => layout.read(reader).modifiedLine.moveLeft(contentLeft).left - 15),
                                top: derived(reader => layout.read(reader).modifiedLine.top),
                            }
                        }, [
                            n.svgElem('path', {
                                d: 'M1 0C1 2.98966 1 4.92087 1 7.49952C1 8.60409 1.89543 9.5 3 9.5H10.5',
                                stroke: 'var(--vscode-editorHoverWidget-foreground)',
                            }),
                            n.svgElem('path', {
                                d: 'M6 6.5L9.99999 9.49998L6 12.5',
                                stroke: 'var(--vscode-editorHoverWidget-foreground)',
                            })
                        ]),
                    ])
                ];
            })
        ]).keepUpdated(this._store);
        this.isHovered = derived(this, reader => {
            return this._div.getIsHovered(this._store).read(reader);
        });
        this._register(this._editor.createOverlayWidget({
            domNode: this._div.element,
            minContentWidthInPx: constObservable(0),
            position: constObservable({ preference: { top: 0, left: 0 } }),
            allowEditorOverflow: false,
        }));
    }
};
WordReplacementView = __decorate([
    __param(3, ILanguageService)
], WordReplacementView);
export { WordReplacementView };
let LineReplacementView = class LineReplacementView extends Disposable {
    removePreviousViewZone(changeAccessor) {
        if (!this._previousViewZoneInfo) {
            return;
        }
        changeAccessor.removeZone(this._previousViewZoneInfo.id);
        const cursorLineNumber = this._editor.cursorLineNumber.get();
        if (cursorLineNumber !== null && cursorLineNumber >= this._previousViewZoneInfo.lineNumber) {
            this._editor.editor.setScrollTop(this._editor.scrollTop.get() - this._previousViewZoneInfo.height);
        }
        this._previousViewZoneInfo = undefined;
    }
    addViewZone(viewZoneInfo, changeAccessor) {
        const activeViewZone = changeAccessor.addZone({
            afterLineNumber: viewZoneInfo.lineNumber - 1,
            heightInPx: viewZoneInfo.height, // move computation to layout?
            domNode: $('div'),
        });
        const cursorLineNumber = this._editor.cursorLineNumber.get();
        if (cursorLineNumber !== null && cursorLineNumber >= viewZoneInfo.lineNumber) {
            this._editor.editor.setScrollTop(this._editor.scrollTop.get() + viewZoneInfo.height);
        }
        this._previousViewZoneInfo = { height: viewZoneInfo.height, lineNumber: viewZoneInfo.lineNumber, id: activeViewZone };
    }
    constructor(_editor, _originalRange, _modifiedRange, _modifiedLines, _replacements, _languageService) {
        super();
        this._editor = _editor;
        this._originalRange = _originalRange;
        this._modifiedRange = _modifiedRange;
        this._modifiedLines = _modifiedLines;
        this._replacements = _replacements;
        this._languageService = _languageService;
        this._originalBubblesDecorationCollection = this._editor.editor.createDecorationsCollection();
        this._originalBubblesDecorationOptions = {
            description: 'inlineCompletions-original-bubble',
            className: 'inlineCompletions-original-bubble',
            stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        };
        this._maxPrefixTrim = getPrefixTrim(this._replacements.flatMap(r => [r.originalRange, r.modifiedRange]), this._originalRange, this._modifiedLines, this._editor.editor);
        this._modifiedLineElements = derived(reader => {
            const lines = [];
            let requiredWidth = 0;
            const maxPrefixTrim = this._maxPrefixTrim.prefixTrim;
            const modifiedBubbles = rangesToBubbleRanges(this._replacements.map(r => r.modifiedRange)).map(r => new Range(r.startLineNumber, r.startColumn - maxPrefixTrim, r.endLineNumber, r.endColumn - maxPrefixTrim));
            const textModel = this._editor.model.get();
            const startLineNumber = this._modifiedRange.startLineNumber;
            for (let i = 0; i < this._modifiedRange.length; i++) {
                const line = document.createElement('div');
                const lineNumber = startLineNumber + i;
                const modLine = this._modifiedLines[i].replace(/\t\n/g, '').slice(maxPrefixTrim);
                const t = textModel.tokenization.tokenizeLinesAt(lineNumber, [modLine])?.[0];
                let tokens;
                if (t) {
                    tokens = TokenArray.fromLineTokens(t).toLineTokens(modLine, this._languageService.languageIdCodec);
                }
                else {
                    tokens = LineTokens.createEmpty(modLine, this._languageService.languageIdCodec);
                }
                const decorations = [];
                for (const modified of modifiedBubbles.filter(b => b.startLineNumber === lineNumber)) {
                    const validatedEndColumn = Math.min(modified.endColumn, modLine.length + 1);
                    decorations.push(new InlineDecoration(new Range(1, modified.startColumn, 1, validatedEndColumn), 'inlineCompletions-modified-bubble', 0 /* InlineDecorationType.Regular */));
                    decorations.push(new InlineDecoration(new Range(1, modified.startColumn, 1, modified.startColumn + 1), 'start', 0 /* InlineDecorationType.Regular */));
                    decorations.push(new InlineDecoration(new Range(1, validatedEndColumn - 1, 1, validatedEndColumn), 'end', 0 /* InlineDecorationType.Regular */));
                }
                const result = renderLines(new LineSource([tokens]), RenderOptions.fromEditor(this._editor.editor).withSetWidth(false), decorations, line, true);
                requiredWidth = Math.max(requiredWidth, result.minWidthInPx);
                lines.push(line);
            }
            return { lines, requiredWidth: requiredWidth - 10 }; // TODO: Width is always too large, why?
        });
        this._viewZoneInfo = observableValue('viewZoneInfo', undefined);
        this._layout = derived(this, reader => {
            const { requiredWidth } = this._modifiedLineElements.read(reader);
            const lineHeight = this._editor.getOption(68 /* EditorOption.lineHeight */).read(reader);
            const contentLeft = this._editor.layoutInfoContentLeft.read(reader);
            const scrollLeft = this._editor.scrollLeft.read(reader);
            const scrollTop = this._editor.scrollTop.read(reader);
            const editorLeftOffset = contentLeft - scrollLeft;
            const PADDING = 4;
            const textModel = this._editor.editor.getModel();
            const { prefixLeftOffset } = this._maxPrefixTrim;
            const originalLineWidths = this._originalRange.mapToLineArray(line => this._editor.editor.getOffsetForColumn(line, textModel.getLineMaxColumn(line)) - prefixLeftOffset);
            const maxLineWidth = Math.max(...originalLineWidths, requiredWidth);
            const startLineNumber = this._originalRange.startLineNumber;
            const endLineNumber = this._originalRange.endLineNumberExclusive - 1;
            const topOfOriginalLines = this._editor.editor.getTopForLineNumber(startLineNumber) - scrollTop;
            const bottomOfOriginalLines = this._editor.editor.getBottomForLineNumber(endLineNumber) - scrollTop;
            // Box Widget positioning
            const originalLinesOverlay = Rect.fromLeftTopWidthHeight(editorLeftOffset + prefixLeftOffset, topOfOriginalLines, maxLineWidth, bottomOfOriginalLines - topOfOriginalLines + PADDING);
            const modifiedLinesOverlay = Rect.fromLeftTopWidthHeight(originalLinesOverlay.left, originalLinesOverlay.bottom + PADDING, originalLinesOverlay.width, this._modifiedRange.length * lineHeight);
            const background = Rect.hull([originalLinesOverlay, modifiedLinesOverlay]).withMargin(PADDING);
            const lowerBackground = background.intersectVertical(new OffsetRange(originalLinesOverlay.bottom, Number.MAX_SAFE_INTEGER));
            const lowerText = new Rect(lowerBackground.left + PADDING, lowerBackground.top + PADDING, lowerBackground.right, lowerBackground.bottom);
            // Add ViewZone if needed
            const shouldShowViewZone = this._editor.editor.getOption(64 /* EditorOption.inlineSuggest */).edits.codeShifting;
            if (shouldShowViewZone) {
                const viewZoneHeight = lowerBackground.height + 2 * PADDING;
                const viewZoneLineNumber = this._originalRange.endLineNumberExclusive;
                const activeViewZone = this._viewZoneInfo.get();
                if (!activeViewZone || activeViewZone.lineNumber !== viewZoneLineNumber || activeViewZone.height !== viewZoneHeight) {
                    this._viewZoneInfo.set({ height: viewZoneHeight, lineNumber: viewZoneLineNumber }, undefined);
                }
            }
            else if (this._viewZoneInfo.get()) {
                this._viewZoneInfo.set(undefined, undefined);
            }
            return {
                originalLinesOverlay,
                modifiedLinesOverlay,
                background,
                lowerBackground,
                lowerText,
                padding: PADDING,
                minContentWidthRequired: maxLineWidth + PADDING * 2,
            };
        });
        this._previousViewZoneInfo = undefined;
        this._viewZone = derived(this, reader => {
            const viewZoneInfo = this._viewZoneInfo.read(reader);
            this._editor.editor.changeViewZones((changeAccessor) => {
                this.removePreviousViewZone(changeAccessor);
                if (!viewZoneInfo) {
                    return;
                }
                this.addViewZone(viewZoneInfo, changeAccessor);
            });
        }).recomputeInitiallyAndOnChange(this._store);
        this._div = n.div({
            class: 'line-replacement',
        }, [
            derived(reader => {
                const layout = mapOutFalsy(this._layout).read(reader);
                if (!layout) {
                    return [];
                }
                const layoutProps = layout.read(reader);
                const scrollLeft = this._editor.scrollLeft.read(reader);
                let contentLeft = this._editor.layoutInfoContentLeft.read(reader);
                let contentWidth = this._editor.contentWidth.read(reader);
                const contentHeight = this._editor.editor.getContentHeight();
                if (scrollLeft === 0) {
                    contentLeft -= layoutProps.padding;
                    contentWidth += layoutProps.padding;
                }
                const lineHeight = this._editor.getOption(68 /* EditorOption.lineHeight */).read(reader);
                const modifiedLines = this._modifiedLineElements.read(reader).lines;
                modifiedLines.forEach(l => {
                    l.style.width = `${layout.read(reader).lowerText.width}px`;
                    l.style.height = `${lineHeight}px`;
                    l.style.position = 'relative';
                });
                return [
                    n.div({
                        style: {
                            position: 'absolute',
                            top: 0,
                            left: contentLeft,
                            width: contentWidth,
                            height: contentHeight,
                            overflow: 'hidden',
                            pointerEvents: 'none',
                        }
                    }, [
                        n.div({
                            style: {
                                position: 'absolute',
                                top: layoutProps.lowerBackground.top - layoutProps.padding,
                                left: layoutProps.lowerBackground.left - contentLeft,
                                width: layoutProps.lowerBackground.width,
                                height: layoutProps.padding * 2,
                                background: 'var(--vscode-editor-background)',
                            },
                        }),
                        n.div({
                            style: {
                                position: 'absolute',
                                ...rectToProps(reader => layout.read(reader).lowerBackground.moveLeft(contentLeft)),
                                borderRadius: '4px',
                                background: 'var(--vscode-editor-background)',
                                boxShadow: 'var(--vscode-scrollbar-shadow) 0 6px 6px -6px',
                                borderTop: '1px solid var(--vscode-editorHoverWidget-border)',
                                overflow: 'hidden',
                            },
                        }, [
                            n.div({
                                style: {
                                    position: 'absolute',
                                    top: 0,
                                    left: 0,
                                    width: '100%',
                                    height: '100%',
                                    background: 'var(--vscode-inlineEdit-modifiedChangedLineBackground)',
                                },
                            })
                        ]),
                        n.div({
                            style: {
                                position: 'absolute',
                                padding: '0px',
                                boxSizing: 'border-box',
                                ...rectToProps(reader => layout.read(reader).lowerText.moveLeft(contentLeft)),
                                fontFamily: this._editor.getOption(51 /* EditorOption.fontFamily */),
                                fontSize: this._editor.getOption(54 /* EditorOption.fontSize */),
                                fontWeight: this._editor.getOption(55 /* EditorOption.fontWeight */),
                                pointerEvents: 'none',
                            }
                        }, [...modifiedLines]),
                        n.div({
                            style: {
                                position: 'absolute',
                                ...rectToProps(reader => layout.read(reader).background.moveLeft(contentLeft)),
                                borderRadius: '4px',
                                border: '1px solid var(--vscode-editorHoverWidget-border)',
                                //background: 'rgba(122, 122, 122, 0.12)', looks better
                                background: 'var(--vscode-inlineEdit-wordReplacementView-background)',
                                pointerEvents: 'none',
                                boxSizing: 'border-box',
                            }
                        }, []),
                    ])
                ];
            })
        ]).keepUpdated(this._store);
        this.isHovered = derived(this, reader => {
            return this._div.getIsHovered(this._store).read(reader);
        });
        this._register(toDisposable(() => this._originalBubblesDecorationCollection.clear()));
        this._register(toDisposable(() => this._editor.editor.changeViewZones(accessor => this.removePreviousViewZone(accessor))));
        const originalBubbles = rangesToBubbleRanges(this._replacements.map(r => r.originalRange));
        this._originalBubblesDecorationCollection.set(originalBubbles.map(r => ({ range: r, options: this._originalBubblesDecorationOptions })));
        this._register(this._editor.createOverlayWidget({
            domNode: this._div.element,
            minContentWidthInPx: derived(reader => {
                return this._layout.read(reader)?.minContentWidthRequired ?? 0;
            }),
            position: constObservable({ preference: { top: 0, left: 0 } }),
            allowEditorOverflow: false,
        }));
    }
};
LineReplacementView = __decorate([
    __param(5, ILanguageService)
], LineReplacementView);
export { LineReplacementView };
function rangesToBubbleRanges(ranges) {
    const result = [];
    while (ranges.length) {
        let range = ranges.shift();
        if (range.startLineNumber !== range.endLineNumber) {
            ranges.push(new Range(range.startLineNumber + 1, 1, range.endLineNumber, range.endColumn));
            range = new Range(range.startLineNumber, range.startColumn, range.startLineNumber, Number.MAX_SAFE_INTEGER); // TODO: this is not correct
        }
        result.push(range);
    }
    return result;
}
//# sourceMappingURL=wordReplacementView.js.map