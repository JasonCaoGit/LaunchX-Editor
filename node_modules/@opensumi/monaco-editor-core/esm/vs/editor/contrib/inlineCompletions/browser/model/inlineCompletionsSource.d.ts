import { Disposable, IDisposable } from '../../../../../base/common/lifecycle.js';
import { IObservable, IReader, ISettableObservable, ITransaction } from '../../../../../base/common/observable.js';
import { ICommandService } from '../../../../../platform/commands/common/commands.js';
import { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';
import { IContextKeyService } from '../../../../../platform/contextkey/common/contextkey.js';
import { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';
import { ILogService } from '../../../../../platform/log/common/log.js';
import { OffsetEdit } from '../../../../common/core/offsetEdit.js';
import { Position } from '../../../../common/core/position.js';
import { Range } from '../../../../common/core/range.js';
import { SingleTextEdit } from '../../../../common/core/textEdit.js';
import { InlineCompletionContext } from '../../../../common/languages.js';
import { ILanguageConfigurationService } from '../../../../common/languages/languageConfigurationRegistry.js';
import { ITextModel } from '../../../../common/model.js';
import { IFeatureDebounceInformation } from '../../../../common/services/languageFeatureDebounce.js';
import { ILanguageFeaturesService } from '../../../../common/services/languageFeatures.js';
import { IModelContentChangedEvent } from '../../../../common/textModelEvents.js';
import { InlineCompletionItem, InlineCompletionProviderResult } from './provideInlineCompletions.js';
export declare class InlineCompletionsSource extends Disposable {
    private readonly _textModel;
    private readonly _versionId;
    private readonly _debounceValue;
    private readonly _languageFeaturesService;
    private readonly _languageConfigurationService;
    private readonly _logService;
    private readonly _configurationService;
    private readonly _instantiationService;
    private static _requestId;
    private readonly _updateOperation;
    readonly inlineCompletions: ISettableObservable<UpToDateInlineCompletions | undefined, void> & IDisposable;
    readonly suggestWidgetInlineCompletions: ISettableObservable<UpToDateInlineCompletions | undefined, void> & IDisposable;
    private readonly _loggingEnabled;
    private readonly _invalidationDelay;
    private readonly _structuredFetchLogger;
    constructor(_textModel: ITextModel, _versionId: IObservable<number | null>, _debounceValue: IFeatureDebounceInformation, _languageFeaturesService: ILanguageFeaturesService, _languageConfigurationService: ILanguageConfigurationService, _logService: ILogService, _configurationService: IConfigurationService, _instantiationService: IInstantiationService);
    private _log;
    readonly loading: ISettableObservable<boolean, void>;
    fetch(position: Position, context: InlineCompletionContext, activeInlineCompletion: InlineCompletionWithUpdatedRange | undefined): Promise<boolean>;
    clear(tx: ITransaction): void;
    clearSuggestWidgetInlineCompletions(tx: ITransaction): void;
    cancelUpdate(): void;
}
declare class UpdateRequest {
    readonly position: Position;
    readonly context: InlineCompletionContext;
    readonly versionId: number;
    constructor(position: Position, context: InlineCompletionContext, versionId: number);
    satisfies(other: UpdateRequest): boolean;
    get isExplicitRequest(): boolean;
}
export declare class UpToDateInlineCompletions implements IDisposable {
    private readonly inlineCompletionProviderResult;
    readonly request: UpdateRequest;
    private readonly _textModel;
    private readonly _versionId;
    private readonly _invalidationDelay;
    private readonly _inlineCompletions;
    get inlineCompletions(): ReadonlyArray<InlineCompletionWithUpdatedRange>;
    private _refCount;
    private readonly _prependedInlineCompletionItems;
    constructor(inlineCompletionProviderResult: InlineCompletionProviderResult, request: UpdateRequest, _textModel: ITextModel, _versionId: IObservable<number | null>, _invalidationDelay: IObservable<number>);
    acceptTextModelChangeEvent(e: IModelContentChangedEvent, tx: ITransaction): void;
    clone(): this;
    dispose(): void;
    prepend(inlineCompletion: InlineCompletionItem, range: Range, addRefToSource: boolean): void;
}
export declare class InlineCompletionWithUpdatedRange {
    readonly inlineCompletion: InlineCompletionItem;
    readonly decorationId: string;
    private readonly _textModel;
    private readonly _modelVersion;
    private readonly _invalidationDelay;
    readonly request: UpdateRequest;
    readonly semanticId: string;
    get forwardStable(): boolean;
    private readonly _updatedRange;
    /**
     * This will be null for ghost text completions
     */
    private _inlineEdit;
    get inlineEdit(): IObservable<OffsetEdit | null>;
    get source(): import("./provideInlineCompletions.js").InlineCompletionList;
    get sourceInlineCompletion(): import("../../../../common/languages.js").InlineCompletion;
    get isInlineEdit(): boolean | undefined;
    private _invalidationTime;
    private _lastChangePartOfInlineEdit;
    constructor(inlineCompletion: InlineCompletionItem, decorationId: string, _textModel: ITextModel, _modelVersion: IObservable<number | null>, _invalidationDelay: IObservable<number>, request: UpdateRequest);
    private _toIndividualEdits;
    acceptTextModelChangeEvent(e: IModelContentChangedEvent, tx: ITransaction): void;
    toInlineCompletion(reader: IReader | undefined): InlineCompletionItem;
    toSingleTextEdit(reader: IReader | undefined): SingleTextEdit;
    isVisible(model: ITextModel, cursorPosition: Position, reader: IReader | undefined): boolean;
    canBeReused(model: ITextModel, position: Position): boolean;
    private _toFilterTextReplacement;
}
interface IRecordableLogEntry {
    sourceId: string;
    time: number;
}
export interface IRecordableEditorLogEntry extends IRecordableLogEntry {
    modelUri: string;
    modelVersion: number;
}
/**
 * The sourceLabel must not contain '@'!
*/
export declare function formatRecordableLogEntry<T extends IRecordableLogEntry>(entry: T): string;
export declare class StructuredLogger<T extends IRecordableLogEntry> extends Disposable {
    private readonly _contextKey;
    private readonly _contextKeyService;
    private readonly _commandService;
    static cast<T extends IRecordableLogEntry>(): typeof StructuredLogger<T>;
    private readonly _contextKeyValue;
    constructor(_contextKey: string, _contextKeyService: IContextKeyService, _commandService: ICommandService);
    readonly isEnabled: IObservable<boolean>;
    log(data: T): boolean;
}
export declare function observableContextKey<T>(key: string, contextKeyService: IContextKeyService): IObservable<T | undefined>;
export {};
