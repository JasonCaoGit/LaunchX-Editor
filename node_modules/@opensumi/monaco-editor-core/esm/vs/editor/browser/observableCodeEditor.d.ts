import { Disposable, DisposableStore, IDisposable } from '../../base/common/lifecycle.js';
import { IObservable, IObservableWithChange, ITransaction } from '../../base/common/observable.js';
import { EditorOption, FindComputedEditorOptionValueById } from '../common/config/editorOptions.js';
import { LineRange } from '../common/core/lineRange.js';
import { OffsetRange } from '../common/core/offsetRange.js';
import { Position } from '../common/core/position.js';
import { Selection } from '../common/core/selection.js';
import { ICursorSelectionChangedEvent } from '../common/cursorEvents.js';
import { IModelDeltaDecoration, ITextModel } from '../common/model.js';
import { IModelContentChangedEvent } from '../common/textModelEvents.js';
import { ICodeEditor, IOverlayWidgetPosition, IPasteEvent } from './editorBrowser.js';
import { Point } from './point.js';
/**
 * Returns a facade for the code editor that provides observables for various states/events.
*/
export declare function observableCodeEditor(editor: ICodeEditor): ObservableCodeEditor;
export declare class ObservableCodeEditor extends Disposable {
    readonly editor: ICodeEditor;
    private static readonly _map;
    /**
     * Make sure that editor is not disposed yet!
    */
    static get(editor: ICodeEditor): ObservableCodeEditor;
    private _updateCounter;
    private _currentTransaction;
    private _beginUpdate;
    private _endUpdate;
    private constructor();
    forceUpdate(): void;
    forceUpdate<T>(cb: (tx: ITransaction) => T): T;
    private _forceUpdate;
    private readonly _model;
    readonly model: IObservable<ITextModel | null>;
    readonly isReadonly: IObservable<boolean>;
    private readonly _versionId;
    readonly versionId: IObservableWithChange<number | null, IModelContentChangedEvent | undefined>;
    private readonly _selections;
    readonly selections: IObservableWithChange<Selection[] | null, ICursorSelectionChangedEvent | undefined>;
    readonly positions: IObservable<readonly Position[] | null>;
    readonly isFocused: IObservable<boolean>;
    readonly isTextFocused: IObservable<boolean>;
    readonly inComposition: IObservable<boolean>;
    readonly value: import("../../base/common/observable.js").ISettableObservable<string, void>;
    readonly valueIsEmpty: IObservable<boolean>;
    readonly cursorSelection: IObservable<Selection | null>;
    readonly cursorPosition: IObservable<Position | null>;
    readonly cursorLineNumber: IObservable<number | null>;
    readonly onDidType: import("../../base/common/observable.js").IObservableSignal<string>;
    readonly onDidPaste: import("../../base/common/observable.js").IObservableSignal<IPasteEvent>;
    readonly scrollTop: IObservable<number>;
    readonly scrollLeft: IObservable<number>;
    readonly layoutInfo: IObservable<import("../common/config/editorOptions.js").EditorLayoutInfo>;
    readonly layoutInfoContentLeft: IObservable<number>;
    readonly layoutInfoDecorationsLeft: IObservable<number>;
    readonly layoutInfoWidth: IObservable<number>;
    readonly contentWidth: IObservable<number>;
    getOption<T extends EditorOption>(id: T): IObservable<FindComputedEditorOptionValueById<T>>;
    setDecorations(decorations: IObservable<IModelDeltaDecoration[]>): IDisposable;
    private _widgetCounter;
    createOverlayWidget(widget: IObservableOverlayWidget): IDisposable;
    observeLineOffsetRange(lineRange: IObservable<LineRange>, store: DisposableStore): IObservable<OffsetRange>;
    observePosition(position: IObservable<Position | null>, store: DisposableStore): IObservable<Point | null>;
}
interface IObservableOverlayWidget {
    get domNode(): HTMLElement;
    readonly position: IObservable<IOverlayWidgetPosition | null>;
    readonly minContentWidthInPx: IObservable<number>;
    get allowEditorOverflow(): boolean;
}
export {};
