{"version":3,"sources":["file:///Users/kw/github/monaco-editor-core/out-editor-esm/vs/editor/common/core/offsetEdit.ts","vs/editor/common/core/offsetEdit.ts"],"names":[],"mappings":"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","file":"offsetEdit.js","sourceRoot":"file:///Users/kw/github/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\n\n/**\n * Describes an edit to a (0-based) string.\n * Use `TextEdit` to describe edits for a 1-based line/column text.\n*/\nexport class OffsetEdit {\n\tpublic static readonly empty = new OffsetEdit([]);\n\n\tpublic static fromJson(data: IOffsetEdit): OffsetEdit {\n\t\treturn new OffsetEdit(data.map(SingleOffsetEdit.fromJson));\n\t}\n\n\tpublic static replace(\n\t\trange: OffsetRange,\n\t\tnewText: string,\n\t): OffsetEdit {\n\t\treturn new OffsetEdit([new SingleOffsetEdit(range, newText)]);\n\t}\n\n\tpublic static insert(\n\t\toffset: number,\n\t\tinsertText: string,\n\t): OffsetEdit {\n\t\treturn OffsetEdit.replace(OffsetRange.emptyAt(offset), insertText);\n\t}\n\n\tconstructor(\n\t\tpublic readonly edits: readonly SingleOffsetEdit[],\n\t) {\n\t\tlet lastEndEx = -1;\n\t\tfor (const edit of edits) {\n\t\t\tif (!(edit.replaceRange.start >= lastEndEx)) {\n\t\t\t\tthrow new BugIndicatingError(`Edits must be disjoint and sorted. Found ${edit} after ${lastEndEx}`);\n\t\t\t}\n\t\t\tlastEndEx = edit.replaceRange.endExclusive;\n\t\t}\n\t}\n\n\tnormalize(): OffsetEdit {\n\t\tconst edits: SingleOffsetEdit[] = [];\n\t\tlet lastEdit: SingleOffsetEdit | undefined;\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edit.newText.length === 0 && edit.replaceRange.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastEdit && lastEdit.replaceRange.endExclusive === edit.replaceRange.start) {\n\t\t\t\tlastEdit = new SingleOffsetEdit(\n\t\t\t\t\tlastEdit.replaceRange.join(edit.replaceRange),\n\t\t\t\t\tlastEdit.newText + edit.newText,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tif (lastEdit) {\n\t\t\t\t\tedits.push(lastEdit);\n\t\t\t\t}\n\t\t\t\tlastEdit = edit;\n\t\t\t}\n\t\t}\n\t\tif (lastEdit) {\n\t\t\tedits.push(lastEdit);\n\t\t}\n\t\treturn new OffsetEdit(edits);\n\t}\n\n\ttoString() {\n\t\tconst edits = this.edits.map(e => e.toString()).join(', ');\n\t\treturn `[${edits}]`;\n\t}\n\n\tapply(str: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tresultText.push(str.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(str.substring(pos));\n\t\treturn resultText.join('');\n\t}\n\n\tcompose(other: OffsetEdit): OffsetEdit {\n\t\treturn joinEdits(this, other);\n\t}\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tinverse(originalStr: string): OffsetEdit {\n\t\tconst edits: SingleOffsetEdit[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tedits.push(new SingleOffsetEdit(\n\t\t\t\tOffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),\n\t\t\t\toriginalStr.substring(e.replaceRange.start, e.replaceRange.endExclusive),\n\t\t\t));\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn new OffsetEdit(edits);\n\t}\n\n\tgetNewTextRanges(): OffsetRange[] {\n\t\tconst ranges: OffsetRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tranges.push(OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),);\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.edits.length === 0;\n\t}\n\n\t/**\n\t * Consider `t1 := text o base` and `t2 := text o this`.\n\t * We are interested in `tm := tryMerge(t1, t2, base: text)`.\n\t * For that, we compute `tm' := t1 o base o this.rebase(base)`\n\t * such that `tm' === tm`.\n\t */\n\ttryRebase(base: OffsetEdit): OffsetEdit;\n\ttryRebase(base: OffsetEdit, noOverlap: true): OffsetEdit | undefined;\n\ttryRebase(base: OffsetEdit, noOverlap?: true): OffsetEdit | undefined {\n\t\tconst newEdits: SingleOffsetEdit[] = [];\n\n\t\tlet baseIdx = 0;\n\t\tlet ourIdx = 0;\n\t\tlet offset = 0;\n\n\t\twhile (ourIdx < this.edits.length || baseIdx < base.edits.length) {\n\t\t\t// take the edit that starts first\n\t\t\tconst baseEdit = base.edits[baseIdx];\n\t\t\tconst ourEdit = this.edits[ourIdx];\n\n\t\t\tif (!ourEdit) {\n\t\t\t\t// We processed all our edits\n\t\t\t\tbreak;\n\t\t\t} else if (!baseEdit) {\n\t\t\t\t// no more edits from base\n\t\t\t\tnewEdits.push(new SingleOffsetEdit(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText,\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else if (ourEdit.replaceRange.intersectsOrTouches(baseEdit.replaceRange)) {\n\t\t\t\tourIdx++; // Don't take our edit, as it is conflicting -> skip\n\t\t\t\tif (noOverlap) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t} else if (ourEdit.replaceRange.start < baseEdit.replaceRange.start) {\n\t\t\t\t// Our edit starts first\n\t\t\t\tnewEdits.push(new SingleOffsetEdit(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText,\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else {\n\t\t\t\tbaseIdx++;\n\t\t\t\toffset += baseEdit.newText.length - baseEdit.replaceRange.length;\n\t\t\t}\n\t\t}\n\n\t\treturn new OffsetEdit(newEdits);\n\t}\n\n\tapplyToOffset(originalOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edit.replaceRange.start <= originalOffset) {\n\t\t\t\tif (originalOffset < edit.replaceRange.endExclusive) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start + accumulatedDelta;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += edit.newText.length - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn originalOffset + accumulatedDelta;\n\t}\n\n\tapplyToOffsetRange(originalRange: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.applyToOffset(originalRange.start),\n\t\t\tthis.applyToOffset(originalRange.endExclusive)\n\t\t);\n\t}\n\n\tapplyInverseToOffset(postEditsOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tconst editLength = edit.newText.length;\n\t\t\tif (edit.replaceRange.start <= postEditsOffset - accumulatedDelta) {\n\t\t\t\tif (postEditsOffset - accumulatedDelta < edit.replaceRange.start + editLength) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += editLength - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn postEditsOffset - accumulatedDelta;\n\t}\n}\n\nexport type IOffsetEdit = ISingleOffsetEdit[];\n\nexport interface ISingleOffsetEdit {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class SingleOffsetEdit {\n\tpublic static fromJson(data: ISingleOffsetEdit): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(OffsetRange.ofStartAndLength(data.pos, data.len), data.txt);\n\t}\n\n\tpublic static insert(offset: number, text: string): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(range, text);\n\t}\n\n\tconstructor(\n\t\tpublic readonly replaceRange: OffsetRange,\n\t\tpublic readonly newText: string,\n\t) { }\n\n\ttoString(): string {\n\t\treturn `${this.replaceRange} -> \"${this.newText}\"`;\n\t}\n\n\tget isEmpty() {\n\t\treturn this.newText.length === 0 && this.replaceRange.length === 0;\n\t}\n\n\tapply(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\tgetRangeAfterApply(): OffsetRange {\n\t\treturn new OffsetRange(this.replaceRange.start, this.replaceRange.start + this.newText.length);\n\t}\n}\n\n/**\n * Invariant:\n * ```\n * edits2.apply(edits1.apply(str)) = join(edits1, edits2).apply(str)\n * ```\n */\nfunction joinEdits(edits1: OffsetEdit, edits2: OffsetEdit): OffsetEdit {\n\tedits1 = edits1.normalize();\n\tedits2 = edits2.normalize();\n\n\tif (edits1.isEmpty) { return edits2; }\n\tif (edits2.isEmpty) { return edits1; }\n\n\tconst edit1Queue = [...edits1.edits];\n\tconst result: SingleOffsetEdit[] = [];\n\n\tlet edit1ToEdit2 = 0;\n\n\tfor (const edit2 of edits2.edits) {\n\t\t// Copy over edit1 unmodified until it touches edit2.\n\t\twhile (true) {\n\t\t\tconst edit1 = edit1Queue[0]!;\n\t\t\tif (!edit1 || edit1.replaceRange.start + edit1ToEdit2 + edit1.newText.length >= edit2.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tedit1Queue.shift();\n\n\t\t\tresult.push(edit1);\n\t\t\tedit1ToEdit2 += edit1.newText.length - edit1.replaceRange.length;\n\t\t}\n\n\t\tconst firstEdit1ToEdit2 = edit1ToEdit2;\n\t\tlet firstIntersecting: SingleOffsetEdit | undefined; // or touching\n\t\tlet lastIntersecting: SingleOffsetEdit | undefined; // or touching\n\n\t\twhile (true) {\n\t\t\tconst edit1 = edit1Queue[0];\n\t\t\tif (!edit1 || edit1.replaceRange.start + edit1ToEdit2 > edit2.replaceRange.endExclusive) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// else we intersect, because the new end of edit1 is after or equal to our start\n\n\t\t\tif (!firstIntersecting) {\n\t\t\t\tfirstIntersecting = edit1;\n\t\t\t}\n\t\t\tlastIntersecting = edit1;\n\t\t\tedit1Queue.shift();\n\n\t\t\tedit1ToEdit2 += edit1.newText.length - edit1.replaceRange.length;\n\t\t}\n\n\t\tif (!firstIntersecting) {\n\t\t\tresult.push(new SingleOffsetEdit(edit2.replaceRange.delta(-edit1ToEdit2), edit2.newText));\n\t\t} else {\n\t\t\tlet prefix = '';\n\t\t\tconst prefixLength = edit2.replaceRange.start - (firstIntersecting.replaceRange.start + firstEdit1ToEdit2);\n\t\t\tif (prefixLength > 0) {\n\t\t\t\tprefix = firstIntersecting.newText.slice(0, prefixLength);\n\t\t\t}\n\t\t\tconst suffixLength = (lastIntersecting!.replaceRange.endExclusive + edit1ToEdit2) - edit2.replaceRange.endExclusive;\n\t\t\tif (suffixLength > 0) {\n\t\t\t\tconst e = new SingleOffsetEdit(OffsetRange.ofStartAndLength(lastIntersecting!.replaceRange.endExclusive, 0), lastIntersecting!.newText.slice(-suffixLength));\n\t\t\t\tedit1Queue.unshift(e);\n\t\t\t\tedit1ToEdit2 -= e.newText.length - e.replaceRange.length;\n\t\t\t}\n\t\t\tconst newText = prefix + edit2.newText;\n\n\t\t\tconst newReplaceRange = new OffsetRange(\n\t\t\t\tMath.min(firstIntersecting.replaceRange.start, edit2.replaceRange.start - firstEdit1ToEdit2),\n\t\t\t\tedit2.replaceRange.endExclusive - edit1ToEdit2\n\t\t\t);\n\t\t\tresult.push(new SingleOffsetEdit(newReplaceRange, newText));\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tconst item = edit1Queue.shift();\n\t\tif (!item) { break; }\n\t\tresult.push(item);\n\t}\n\n\treturn new OffsetEdit(result).normalize();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\n\n/**\n * Describes an edit to a (0-based) string.\n * Use `TextEdit` to describe edits for a 1-based line/column text.\n*/\nexport class OffsetEdit {\n\tpublic static readonly empty = new OffsetEdit([]);\n\n\tpublic static fromJson(data: IOffsetEdit): OffsetEdit {\n\t\treturn new OffsetEdit(data.map(SingleOffsetEdit.fromJson));\n\t}\n\n\tpublic static replace(\n\t\trange: OffsetRange,\n\t\tnewText: string,\n\t): OffsetEdit {\n\t\treturn new OffsetEdit([new SingleOffsetEdit(range, newText)]);\n\t}\n\n\tpublic static insert(\n\t\toffset: number,\n\t\tinsertText: string,\n\t): OffsetEdit {\n\t\treturn OffsetEdit.replace(OffsetRange.emptyAt(offset), insertText);\n\t}\n\n\tconstructor(\n\t\tpublic readonly edits: readonly SingleOffsetEdit[],\n\t) {\n\t\tlet lastEndEx = -1;\n\t\tfor (const edit of edits) {\n\t\t\tif (!(edit.replaceRange.start >= lastEndEx)) {\n\t\t\t\tthrow new BugIndicatingError(`Edits must be disjoint and sorted. Found ${edit} after ${lastEndEx}`);\n\t\t\t}\n\t\t\tlastEndEx = edit.replaceRange.endExclusive;\n\t\t}\n\t}\n\n\tnormalize(): OffsetEdit {\n\t\tconst edits: SingleOffsetEdit[] = [];\n\t\tlet lastEdit: SingleOffsetEdit | undefined;\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edit.newText.length === 0 && edit.replaceRange.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastEdit && lastEdit.replaceRange.endExclusive === edit.replaceRange.start) {\n\t\t\t\tlastEdit = new SingleOffsetEdit(\n\t\t\t\t\tlastEdit.replaceRange.join(edit.replaceRange),\n\t\t\t\t\tlastEdit.newText + edit.newText,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tif (lastEdit) {\n\t\t\t\t\tedits.push(lastEdit);\n\t\t\t\t}\n\t\t\t\tlastEdit = edit;\n\t\t\t}\n\t\t}\n\t\tif (lastEdit) {\n\t\t\tedits.push(lastEdit);\n\t\t}\n\t\treturn new OffsetEdit(edits);\n\t}\n\n\ttoString() {\n\t\tconst edits = this.edits.map(e => e.toString()).join(', ');\n\t\treturn `[${edits}]`;\n\t}\n\n\tapply(str: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tresultText.push(str.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(str.substring(pos));\n\t\treturn resultText.join('');\n\t}\n\n\tcompose(other: OffsetEdit): OffsetEdit {\n\t\treturn joinEdits(this, other);\n\t}\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tinverse(originalStr: string): OffsetEdit {\n\t\tconst edits: SingleOffsetEdit[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tedits.push(new SingleOffsetEdit(\n\t\t\t\tOffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),\n\t\t\t\toriginalStr.substring(e.replaceRange.start, e.replaceRange.endExclusive),\n\t\t\t));\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn new OffsetEdit(edits);\n\t}\n\n\tgetNewTextRanges(): OffsetRange[] {\n\t\tconst ranges: OffsetRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tranges.push(OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),);\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.edits.length === 0;\n\t}\n\n\t/**\n\t * Consider `t1 := text o base` and `t2 := text o this`.\n\t * We are interested in `tm := tryMerge(t1, t2, base: text)`.\n\t * For that, we compute `tm' := t1 o base o this.rebase(base)`\n\t * such that `tm' === tm`.\n\t */\n\ttryRebase(base: OffsetEdit): OffsetEdit;\n\ttryRebase(base: OffsetEdit, noOverlap: true): OffsetEdit | undefined;\n\ttryRebase(base: OffsetEdit, noOverlap?: true): OffsetEdit | undefined {\n\t\tconst newEdits: SingleOffsetEdit[] = [];\n\n\t\tlet baseIdx = 0;\n\t\tlet ourIdx = 0;\n\t\tlet offset = 0;\n\n\t\twhile (ourIdx < this.edits.length || baseIdx < base.edits.length) {\n\t\t\t// take the edit that starts first\n\t\t\tconst baseEdit = base.edits[baseIdx];\n\t\t\tconst ourEdit = this.edits[ourIdx];\n\n\t\t\tif (!ourEdit) {\n\t\t\t\t// We processed all our edits\n\t\t\t\tbreak;\n\t\t\t} else if (!baseEdit) {\n\t\t\t\t// no more edits from base\n\t\t\t\tnewEdits.push(new SingleOffsetEdit(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText,\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else if (ourEdit.replaceRange.intersectsOrTouches(baseEdit.replaceRange)) {\n\t\t\t\tourIdx++; // Don't take our edit, as it is conflicting -> skip\n\t\t\t\tif (noOverlap) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t} else if (ourEdit.replaceRange.start < baseEdit.replaceRange.start) {\n\t\t\t\t// Our edit starts first\n\t\t\t\tnewEdits.push(new SingleOffsetEdit(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText,\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else {\n\t\t\t\tbaseIdx++;\n\t\t\t\toffset += baseEdit.newText.length - baseEdit.replaceRange.length;\n\t\t\t}\n\t\t}\n\n\t\treturn new OffsetEdit(newEdits);\n\t}\n\n\tapplyToOffset(originalOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edit.replaceRange.start <= originalOffset) {\n\t\t\t\tif (originalOffset < edit.replaceRange.endExclusive) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start + accumulatedDelta;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += edit.newText.length - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn originalOffset + accumulatedDelta;\n\t}\n\n\tapplyToOffsetRange(originalRange: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.applyToOffset(originalRange.start),\n\t\t\tthis.applyToOffset(originalRange.endExclusive)\n\t\t);\n\t}\n\n\tapplyInverseToOffset(postEditsOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tconst editLength = edit.newText.length;\n\t\t\tif (edit.replaceRange.start <= postEditsOffset - accumulatedDelta) {\n\t\t\t\tif (postEditsOffset - accumulatedDelta < edit.replaceRange.start + editLength) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += editLength - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn postEditsOffset - accumulatedDelta;\n\t}\n}\n\nexport type IOffsetEdit = ISingleOffsetEdit[];\n\nexport interface ISingleOffsetEdit {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class SingleOffsetEdit {\n\tpublic static fromJson(data: ISingleOffsetEdit): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(OffsetRange.ofStartAndLength(data.pos, data.len), data.txt);\n\t}\n\n\tpublic static insert(offset: number, text: string): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): SingleOffsetEdit {\n\t\treturn new SingleOffsetEdit(range, text);\n\t}\n\n\tconstructor(\n\t\tpublic readonly replaceRange: OffsetRange,\n\t\tpublic readonly newText: string,\n\t) { }\n\n\ttoString(): string {\n\t\treturn `${this.replaceRange} -> \"${this.newText}\"`;\n\t}\n\n\tget isEmpty() {\n\t\treturn this.newText.length === 0 && this.replaceRange.length === 0;\n\t}\n\n\tapply(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\tgetRangeAfterApply(): OffsetRange {\n\t\treturn new OffsetRange(this.replaceRange.start, this.replaceRange.start + this.newText.length);\n\t}\n}\n\n/**\n * Invariant:\n * ```\n * edits2.apply(edits1.apply(str)) = join(edits1, edits2).apply(str)\n * ```\n */\nfunction joinEdits(edits1: OffsetEdit, edits2: OffsetEdit): OffsetEdit {\n\tedits1 = edits1.normalize();\n\tedits2 = edits2.normalize();\n\n\tif (edits1.isEmpty) { return edits2; }\n\tif (edits2.isEmpty) { return edits1; }\n\n\tconst edit1Queue = [...edits1.edits];\n\tconst result: SingleOffsetEdit[] = [];\n\n\tlet edit1ToEdit2 = 0;\n\n\tfor (const edit2 of edits2.edits) {\n\t\t// Copy over edit1 unmodified until it touches edit2.\n\t\twhile (true) {\n\t\t\tconst edit1 = edit1Queue[0]!;\n\t\t\tif (!edit1 || edit1.replaceRange.start + edit1ToEdit2 + edit1.newText.length >= edit2.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tedit1Queue.shift();\n\n\t\t\tresult.push(edit1);\n\t\t\tedit1ToEdit2 += edit1.newText.length - edit1.replaceRange.length;\n\t\t}\n\n\t\tconst firstEdit1ToEdit2 = edit1ToEdit2;\n\t\tlet firstIntersecting: SingleOffsetEdit | undefined; // or touching\n\t\tlet lastIntersecting: SingleOffsetEdit | undefined; // or touching\n\n\t\twhile (true) {\n\t\t\tconst edit1 = edit1Queue[0];\n\t\t\tif (!edit1 || edit1.replaceRange.start + edit1ToEdit2 > edit2.replaceRange.endExclusive) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// else we intersect, because the new end of edit1 is after or equal to our start\n\n\t\t\tif (!firstIntersecting) {\n\t\t\t\tfirstIntersecting = edit1;\n\t\t\t}\n\t\t\tlastIntersecting = edit1;\n\t\t\tedit1Queue.shift();\n\n\t\t\tedit1ToEdit2 += edit1.newText.length - edit1.replaceRange.length;\n\t\t}\n\n\t\tif (!firstIntersecting) {\n\t\t\tresult.push(new SingleOffsetEdit(edit2.replaceRange.delta(-edit1ToEdit2), edit2.newText));\n\t\t} else {\n\t\t\tlet prefix = '';\n\t\t\tconst prefixLength = edit2.replaceRange.start - (firstIntersecting.replaceRange.start + firstEdit1ToEdit2);\n\t\t\tif (prefixLength > 0) {\n\t\t\t\tprefix = firstIntersecting.newText.slice(0, prefixLength);\n\t\t\t}\n\t\t\tconst suffixLength = (lastIntersecting!.replaceRange.endExclusive + edit1ToEdit2) - edit2.replaceRange.endExclusive;\n\t\t\tif (suffixLength > 0) {\n\t\t\t\tconst e = new SingleOffsetEdit(OffsetRange.ofStartAndLength(lastIntersecting!.replaceRange.endExclusive, 0), lastIntersecting!.newText.slice(-suffixLength));\n\t\t\t\tedit1Queue.unshift(e);\n\t\t\t\tedit1ToEdit2 -= e.newText.length - e.replaceRange.length;\n\t\t\t}\n\t\t\tconst newText = prefix + edit2.newText;\n\n\t\t\tconst newReplaceRange = new OffsetRange(\n\t\t\t\tMath.min(firstIntersecting.replaceRange.start, edit2.replaceRange.start - firstEdit1ToEdit2),\n\t\t\t\tedit2.replaceRange.endExclusive - edit1ToEdit2\n\t\t\t);\n\t\t\tresult.push(new SingleOffsetEdit(newReplaceRange, newText));\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tconst item = edit1Queue.shift();\n\t\tif (!item) { break; }\n\t\tresult.push(item);\n\t}\n\n\treturn new OffsetEdit(result).normalize();\n}\n"]}