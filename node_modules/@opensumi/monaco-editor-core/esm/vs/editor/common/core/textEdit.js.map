{"version":3,"sources":["file:///Users/kw/github/monaco-editor-core/out-editor-esm/vs/editor/common/core/textEdit.ts","vs/editor/common/core/textEdit.ts"],"names":[],"mappings":"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","file":"textEdit.js","sourceRoot":"file:///Users/kw/github/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../base/common/arrays.js';\nimport { assert, assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { commonPrefixLength, commonSuffixLength, splitLines } from '../../../base/common/strings.js';\nimport { ISingleEditOperation } from './editOperation.js';\nimport { LineRange } from './lineRange.js';\nimport { OffsetEdit } from './offsetEdit.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\n\nexport class TextEdit {\n\tpublic static fromOffsetEdit(edit: OffsetEdit, initialState: AbstractText): TextEdit {\n\t\tconst edits = edit.edits.map(e => new SingleTextEdit(initialState.getTransformer().getRange(e.replaceRange), e.newText));\n\t\treturn new TextEdit(edits);\n\t}\n\n\tpublic static single(originalRange: Range, newText: string): TextEdit {\n\t\treturn new TextEdit([new SingleTextEdit(originalRange, newText)]);\n\t}\n\n\tpublic static insert(position: Position, newText: string): TextEdit {\n\t\treturn new TextEdit([new SingleTextEdit(Range.fromPositions(position, position), newText)]);\n\t}\n\n\tconstructor(public readonly edits: readonly SingleTextEdit[]) {\n\t\tassertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n\t}\n\n\t/**\n\t * Joins touching edits and removes empty edits.\n\t */\n\tnormalize(): TextEdit {\n\t\tconst edits: SingleTextEdit[] = [];\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edits.length > 0 && edits[edits.length - 1].range.getEndPosition().equals(edit.range.getStartPosition())) {\n\t\t\t\tconst last = edits[edits.length - 1];\n\t\t\t\tedits[edits.length - 1] = new SingleTextEdit(last.range.plusRange(edit.range), last.text + edit.text);\n\t\t\t} else if (!edit.isEmpty) {\n\t\t\t\tedits.push(edit);\n\t\t\t}\n\t\t}\n\t\treturn new TextEdit(edits);\n\t}\n\n\tmapPosition(position: Position): Position | Range {\n\t\tlet lineDelta = 0;\n\t\tlet curLine = 0;\n\t\tlet columnDeltaInCurLine = 0;\n\n\t\tfor (const edit of this.edits) {\n\t\t\tconst start = edit.range.getStartPosition();\n\n\t\t\tif (position.isBeforeOrEqual(start)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst end = edit.range.getEndPosition();\n\t\t\tconst len = TextLength.ofText(edit.text);\n\t\t\tif (position.isBefore(end)) {\n\t\t\t\tconst startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t\t\t\tconst endPos = len.addToPosition(startPos);\n\t\t\t\treturn rangeFromPositions(startPos, endPos);\n\t\t\t}\n\n\t\t\tif (start.lineNumber + lineDelta !== curLine) {\n\t\t\t\tcolumnDeltaInCurLine = 0;\n\t\t\t}\n\n\t\t\tlineDelta += len.lineCount - (edit.range.endLineNumber - edit.range.startLineNumber);\n\n\t\t\tif (len.lineCount === 0) {\n\t\t\t\tif (end.lineNumber !== start.lineNumber) {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - start.column);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumnDeltaInCurLine = len.columnCount;\n\t\t\t}\n\t\t\tcurLine = end.lineNumber + lineDelta;\n\t\t}\n\n\t\treturn new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t}\n\n\tmapRange(range: Range): Range {\n\t\tfunction getStart(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getStartPosition();\n\t\t}\n\n\t\tfunction getEnd(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getEndPosition();\n\t\t}\n\n\t\tconst start = getStart(this.mapPosition(range.getStartPosition()));\n\t\tconst end = getEnd(this.mapPosition(range.getEndPosition()));\n\n\t\treturn rangeFromPositions(start, end);\n\t}\n\n\t// TODO: `doc` is not needed for this!\n\tinverseMapPosition(positionAfterEdit: Position, doc: AbstractText): Position | Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapPosition(positionAfterEdit);\n\t}\n\n\tinverseMapRange(range: Range, doc: AbstractText): Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapRange(range);\n\t}\n\n\tapply(text: AbstractText): string {\n\t\tlet result = '';\n\t\tlet lastEditEnd = new Position(1, 1);\n\t\tfor (const edit of this.edits) {\n\t\t\tconst editRange = edit.range;\n\t\t\tconst editStart = editRange.getStartPosition();\n\t\t\tconst editEnd = editRange.getEndPosition();\n\n\t\t\tconst r = rangeFromPositions(lastEditEnd, editStart);\n\t\t\tif (!r.isEmpty()) {\n\t\t\t\tresult += text.getValueOfRange(r);\n\t\t\t}\n\t\t\tresult += edit.text;\n\t\t\tlastEditEnd = editEnd;\n\t\t}\n\t\tconst r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n\t\tif (!r.isEmpty()) {\n\t\t\tresult += text.getValueOfRange(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyToString(str: string): string {\n\t\tconst strText = new StringText(str);\n\t\treturn this.apply(strText);\n\t}\n\n\tinverse(doc: AbstractText): TextEdit {\n\t\tconst ranges = this.getNewRanges();\n\t\treturn new TextEdit(this.edits.map((e, idx) => new SingleTextEdit(ranges[idx], doc.getValueOfRange(e.range))));\n\t}\n\n\tgetNewRanges(): Range[] {\n\t\tconst newRanges: Range[] = [];\n\t\tlet previousEditEndLineNumber = 0;\n\t\tlet lineOffset = 0;\n\t\tlet columnOffset = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tconst textLength = TextLength.ofText(edit.text);\n\t\t\tconst newRangeStart = Position.lift({\n\t\t\t\tlineNumber: edit.range.startLineNumber + lineOffset,\n\t\t\t\tcolumn: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t\t});\n\t\t\tconst newRange = textLength.createRange(newRangeStart);\n\t\t\tnewRanges.push(newRange);\n\t\t\tlineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n\t\t\tcolumnOffset = newRange.endColumn - edit.range.endColumn;\n\t\t\tpreviousEditEndLineNumber = edit.range.endLineNumber;\n\t\t}\n\t\treturn newRanges;\n\t}\n\n\ttoSingle(text: AbstractText) {\n\t\tif (this.edits.length === 0) { throw new BugIndicatingError(); }\n\t\tif (this.edits.length === 1) { return this.edits[0]; }\n\n\t\tconst startPos = this.edits[0].range.getStartPosition();\n\t\tconst endPos = this.edits[this.edits.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < this.edits.length; i++) {\n\t\t\tconst curEdit = this.edits[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < this.edits.length - 1) {\n\t\t\t\tconst nextEdit = this.edits[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = text.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new SingleTextEdit(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tequals(other: TextEdit): boolean {\n\t\treturn equals(this.edits, other.edits, (a, b) => a.equals(b));\n\t}\n}\n\nexport class SingleTextEdit {\n\tpublic static joinEdits(edits: SingleTextEdit[], initialValue: AbstractText): SingleTextEdit {\n\t\tif (edits.length === 0) { throw new BugIndicatingError(); }\n\t\tif (edits.length === 1) { return edits[0]; }\n\n\t\tconst startPos = edits[0].range.getStartPosition();\n\t\tconst endPos = edits[edits.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst curEdit = edits[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < edits.length - 1) {\n\t\t\t\tconst nextEdit = edits[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = initialValue.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new SingleTextEdit(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string,\n\t) {\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.range.isEmpty() && this.text.length === 0;\n\t}\n\n\tstatic equals(first: SingleTextEdit, second: SingleTextEdit) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\t}\n\n\tpublic toSingleEditOperation(): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: this.range,\n\t\t\ttext: this.text,\n\t\t};\n\t}\n\n\tpublic toEdit(): TextEdit {\n\t\treturn new TextEdit([this]);\n\t}\n\n\tpublic equals(other: SingleTextEdit): boolean {\n\t\treturn SingleTextEdit.equals(this, other);\n\t}\n\n\tpublic extendToCoverRange(range: Range, initialValue: AbstractText): SingleTextEdit {\n\t\tif (this.range.containsRange(range)) { return this; }\n\n\t\tconst newRange = this.range.plusRange(range);\n\t\tconst textBefore = initialValue.getValueOfRange(Range.fromPositions(newRange.getStartPosition(), this.range.getStartPosition()));\n\t\tconst textAfter = initialValue.getValueOfRange(Range.fromPositions(this.range.getEndPosition(), newRange.getEndPosition()));\n\t\tconst newText = textBefore + this.text + textAfter;\n\t\treturn new SingleTextEdit(newRange, newText);\n\t}\n\n\tpublic extendToFullLine(initialValue: AbstractText): SingleTextEdit {\n\t\tconst newRange = new Range(\n\t\t\tthis.range.startLineNumber,\n\t\t\t1,\n\t\t\tthis.range.endLineNumber,\n\t\t\tinitialValue.getTransformer().getLineLength(this.range.endLineNumber) + 1\n\t\t);\n\t\treturn this.extendToCoverRange(newRange, initialValue);\n\t}\n\n\tpublic removeCommonPrefix(text: AbstractText): SingleTextEdit {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonPrefixLen = commonPrefixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst start = TextLength.ofText(normalizedOriginalText.substring(0, commonPrefixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new SingleTextEdit(range, newText);\n\t}\n\n\tpublic isEffectiveDeletion(text: AbstractText): boolean {\n\t\tlet newText = this.text.replaceAll('\\r\\n', '\\n');\n\t\tlet existingText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst l = commonPrefixLength(newText, existingText);\n\t\tnewText = newText.substring(l);\n\t\texistingText = existingText.substring(l);\n\t\tconst r = commonSuffixLength(newText, existingText);\n\t\tnewText = newText.substring(0, newText.length - r);\n\t\texistingText = existingText.substring(0, existingText.length - r);\n\n\t\treturn newText === '';\n\t}\n}\n\nfunction rangeFromPositions(start: Position, end: Position): Range {\n\tif (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n\t\treturn Range.fromPositions(end, end);\n\t} else if (!start.isBeforeOrEqual(end)) {\n\t\tthrow new BugIndicatingError('start must be before end');\n\t}\n\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\n\nexport abstract class AbstractText {\n\tabstract getValueOfRange(range: Range): string;\n\tabstract readonly length: TextLength;\n\n\tget endPositionExclusive(): Position {\n\t\treturn this.length.addToPosition(new Position(1, 1));\n\t}\n\n\tget lineRange(): LineRange {\n\t\treturn this.length.toLineRange();\n\t}\n\n\tgetValue(): string {\n\t\treturn this.getValueOfRange(this.length.toRange());\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER)).length;\n\t}\n\n\tprivate _transformer: PositionOffsetTransformer | undefined = undefined;\n\n\tgetTransformer(): PositionOffsetTransformer {\n\t\tif (!this._transformer) {\n\t\t\tthis._transformer = new PositionOffsetTransformer(this.getValue());\n\t\t}\n\t\treturn this._transformer;\n\t}\n\n\tgetLineAt(lineNumber: number): string {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER));\n\t}\n\n\tgetLines(): string[] {\n\t\tconst value = this.getValue();\n\t\treturn splitLines(value);\n\t}\n}\n\nexport class LineBasedText extends AbstractText {\n\tconstructor(\n\t\tprivate readonly _getLineContent: (lineNumber: number) => string,\n\t\tprivate readonly _lineCount: number,\n\t) {\n\t\tassert(_lineCount >= 1);\n\n\t\tsuper();\n\t}\n\n\toverride getValueOfRange(range: Range): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\t\tlet result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n\t\tfor (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n\t\t\tresult += '\\n' + this._getLineContent(i);\n\t\t}\n\t\tresult += '\\n' + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n\t\treturn result;\n\t}\n\n\toverride getLineLength(lineNumber: number): number {\n\t\treturn this._getLineContent(lineNumber).length;\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLine = this._getLineContent(this._lineCount);\n\t\treturn new TextLength(this._lineCount - 1, lastLine.length);\n\t}\n}\n\nexport class ArrayText extends LineBasedText {\n\tconstructor(lines: string[]) {\n\t\tsuper(\n\t\t\tlineNumber => lines[lineNumber - 1],\n\t\t\tlines.length\n\t\t);\n\t}\n}\n\nexport class StringText extends AbstractText {\n\tprivate readonly _t = new PositionOffsetTransformer(this.value);\n\n\tconstructor(public readonly value: string) {\n\t\tsuper();\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\treturn this._t.getOffsetRange(range).substring(this.value);\n\t}\n\n\tget length(): TextLength {\n\t\treturn this._t.textLength;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../base/common/arrays.js';\nimport { assert, assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { commonPrefixLength, commonSuffixLength, splitLines } from '../../../base/common/strings.js';\nimport { ISingleEditOperation } from './editOperation.js';\nimport { LineRange } from './lineRange.js';\nimport { OffsetEdit } from './offsetEdit.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\n\nexport class TextEdit {\n\tpublic static fromOffsetEdit(edit: OffsetEdit, initialState: AbstractText): TextEdit {\n\t\tconst edits = edit.edits.map(e => new SingleTextEdit(initialState.getTransformer().getRange(e.replaceRange), e.newText));\n\t\treturn new TextEdit(edits);\n\t}\n\n\tpublic static single(originalRange: Range, newText: string): TextEdit {\n\t\treturn new TextEdit([new SingleTextEdit(originalRange, newText)]);\n\t}\n\n\tpublic static insert(position: Position, newText: string): TextEdit {\n\t\treturn new TextEdit([new SingleTextEdit(Range.fromPositions(position, position), newText)]);\n\t}\n\n\tconstructor(public readonly edits: readonly SingleTextEdit[]) {\n\t\tassertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n\t}\n\n\t/**\n\t * Joins touching edits and removes empty edits.\n\t */\n\tnormalize(): TextEdit {\n\t\tconst edits: SingleTextEdit[] = [];\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edits.length > 0 && edits[edits.length - 1].range.getEndPosition().equals(edit.range.getStartPosition())) {\n\t\t\t\tconst last = edits[edits.length - 1];\n\t\t\t\tedits[edits.length - 1] = new SingleTextEdit(last.range.plusRange(edit.range), last.text + edit.text);\n\t\t\t} else if (!edit.isEmpty) {\n\t\t\t\tedits.push(edit);\n\t\t\t}\n\t\t}\n\t\treturn new TextEdit(edits);\n\t}\n\n\tmapPosition(position: Position): Position | Range {\n\t\tlet lineDelta = 0;\n\t\tlet curLine = 0;\n\t\tlet columnDeltaInCurLine = 0;\n\n\t\tfor (const edit of this.edits) {\n\t\t\tconst start = edit.range.getStartPosition();\n\n\t\t\tif (position.isBeforeOrEqual(start)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst end = edit.range.getEndPosition();\n\t\t\tconst len = TextLength.ofText(edit.text);\n\t\t\tif (position.isBefore(end)) {\n\t\t\t\tconst startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t\t\t\tconst endPos = len.addToPosition(startPos);\n\t\t\t\treturn rangeFromPositions(startPos, endPos);\n\t\t\t}\n\n\t\t\tif (start.lineNumber + lineDelta !== curLine) {\n\t\t\t\tcolumnDeltaInCurLine = 0;\n\t\t\t}\n\n\t\t\tlineDelta += len.lineCount - (edit.range.endLineNumber - edit.range.startLineNumber);\n\n\t\t\tif (len.lineCount === 0) {\n\t\t\t\tif (end.lineNumber !== start.lineNumber) {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - start.column);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumnDeltaInCurLine = len.columnCount;\n\t\t\t}\n\t\t\tcurLine = end.lineNumber + lineDelta;\n\t\t}\n\n\t\treturn new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t}\n\n\tmapRange(range: Range): Range {\n\t\tfunction getStart(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getStartPosition();\n\t\t}\n\n\t\tfunction getEnd(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getEndPosition();\n\t\t}\n\n\t\tconst start = getStart(this.mapPosition(range.getStartPosition()));\n\t\tconst end = getEnd(this.mapPosition(range.getEndPosition()));\n\n\t\treturn rangeFromPositions(start, end);\n\t}\n\n\t// TODO: `doc` is not needed for this!\n\tinverseMapPosition(positionAfterEdit: Position, doc: AbstractText): Position | Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapPosition(positionAfterEdit);\n\t}\n\n\tinverseMapRange(range: Range, doc: AbstractText): Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapRange(range);\n\t}\n\n\tapply(text: AbstractText): string {\n\t\tlet result = '';\n\t\tlet lastEditEnd = new Position(1, 1);\n\t\tfor (const edit of this.edits) {\n\t\t\tconst editRange = edit.range;\n\t\t\tconst editStart = editRange.getStartPosition();\n\t\t\tconst editEnd = editRange.getEndPosition();\n\n\t\t\tconst r = rangeFromPositions(lastEditEnd, editStart);\n\t\t\tif (!r.isEmpty()) {\n\t\t\t\tresult += text.getValueOfRange(r);\n\t\t\t}\n\t\t\tresult += edit.text;\n\t\t\tlastEditEnd = editEnd;\n\t\t}\n\t\tconst r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n\t\tif (!r.isEmpty()) {\n\t\t\tresult += text.getValueOfRange(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyToString(str: string): string {\n\t\tconst strText = new StringText(str);\n\t\treturn this.apply(strText);\n\t}\n\n\tinverse(doc: AbstractText): TextEdit {\n\t\tconst ranges = this.getNewRanges();\n\t\treturn new TextEdit(this.edits.map((e, idx) => new SingleTextEdit(ranges[idx], doc.getValueOfRange(e.range))));\n\t}\n\n\tgetNewRanges(): Range[] {\n\t\tconst newRanges: Range[] = [];\n\t\tlet previousEditEndLineNumber = 0;\n\t\tlet lineOffset = 0;\n\t\tlet columnOffset = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tconst textLength = TextLength.ofText(edit.text);\n\t\t\tconst newRangeStart = Position.lift({\n\t\t\t\tlineNumber: edit.range.startLineNumber + lineOffset,\n\t\t\t\tcolumn: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t\t});\n\t\t\tconst newRange = textLength.createRange(newRangeStart);\n\t\t\tnewRanges.push(newRange);\n\t\t\tlineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n\t\t\tcolumnOffset = newRange.endColumn - edit.range.endColumn;\n\t\t\tpreviousEditEndLineNumber = edit.range.endLineNumber;\n\t\t}\n\t\treturn newRanges;\n\t}\n\n\ttoSingle(text: AbstractText) {\n\t\tif (this.edits.length === 0) { throw new BugIndicatingError(); }\n\t\tif (this.edits.length === 1) { return this.edits[0]; }\n\n\t\tconst startPos = this.edits[0].range.getStartPosition();\n\t\tconst endPos = this.edits[this.edits.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < this.edits.length; i++) {\n\t\t\tconst curEdit = this.edits[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < this.edits.length - 1) {\n\t\t\t\tconst nextEdit = this.edits[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = text.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new SingleTextEdit(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tequals(other: TextEdit): boolean {\n\t\treturn equals(this.edits, other.edits, (a, b) => a.equals(b));\n\t}\n}\n\nexport class SingleTextEdit {\n\tpublic static joinEdits(edits: SingleTextEdit[], initialValue: AbstractText): SingleTextEdit {\n\t\tif (edits.length === 0) { throw new BugIndicatingError(); }\n\t\tif (edits.length === 1) { return edits[0]; }\n\n\t\tconst startPos = edits[0].range.getStartPosition();\n\t\tconst endPos = edits[edits.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst curEdit = edits[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < edits.length - 1) {\n\t\t\t\tconst nextEdit = edits[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = initialValue.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new SingleTextEdit(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string,\n\t) {\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.range.isEmpty() && this.text.length === 0;\n\t}\n\n\tstatic equals(first: SingleTextEdit, second: SingleTextEdit) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\t}\n\n\tpublic toSingleEditOperation(): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: this.range,\n\t\t\ttext: this.text,\n\t\t};\n\t}\n\n\tpublic toEdit(): TextEdit {\n\t\treturn new TextEdit([this]);\n\t}\n\n\tpublic equals(other: SingleTextEdit): boolean {\n\t\treturn SingleTextEdit.equals(this, other);\n\t}\n\n\tpublic extendToCoverRange(range: Range, initialValue: AbstractText): SingleTextEdit {\n\t\tif (this.range.containsRange(range)) { return this; }\n\n\t\tconst newRange = this.range.plusRange(range);\n\t\tconst textBefore = initialValue.getValueOfRange(Range.fromPositions(newRange.getStartPosition(), this.range.getStartPosition()));\n\t\tconst textAfter = initialValue.getValueOfRange(Range.fromPositions(this.range.getEndPosition(), newRange.getEndPosition()));\n\t\tconst newText = textBefore + this.text + textAfter;\n\t\treturn new SingleTextEdit(newRange, newText);\n\t}\n\n\tpublic extendToFullLine(initialValue: AbstractText): SingleTextEdit {\n\t\tconst newRange = new Range(\n\t\t\tthis.range.startLineNumber,\n\t\t\t1,\n\t\t\tthis.range.endLineNumber,\n\t\t\tinitialValue.getTransformer().getLineLength(this.range.endLineNumber) + 1\n\t\t);\n\t\treturn this.extendToCoverRange(newRange, initialValue);\n\t}\n\n\tpublic removeCommonPrefix(text: AbstractText): SingleTextEdit {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonPrefixLen = commonPrefixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst start = TextLength.ofText(normalizedOriginalText.substring(0, commonPrefixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new SingleTextEdit(range, newText);\n\t}\n\n\tpublic isEffectiveDeletion(text: AbstractText): boolean {\n\t\tlet newText = this.text.replaceAll('\\r\\n', '\\n');\n\t\tlet existingText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst l = commonPrefixLength(newText, existingText);\n\t\tnewText = newText.substring(l);\n\t\texistingText = existingText.substring(l);\n\t\tconst r = commonSuffixLength(newText, existingText);\n\t\tnewText = newText.substring(0, newText.length - r);\n\t\texistingText = existingText.substring(0, existingText.length - r);\n\n\t\treturn newText === '';\n\t}\n}\n\nfunction rangeFromPositions(start: Position, end: Position): Range {\n\tif (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n\t\treturn Range.fromPositions(end, end);\n\t} else if (!start.isBeforeOrEqual(end)) {\n\t\tthrow new BugIndicatingError('start must be before end');\n\t}\n\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\n\nexport abstract class AbstractText {\n\tabstract getValueOfRange(range: Range): string;\n\tabstract readonly length: TextLength;\n\n\tget endPositionExclusive(): Position {\n\t\treturn this.length.addToPosition(new Position(1, 1));\n\t}\n\n\tget lineRange(): LineRange {\n\t\treturn this.length.toLineRange();\n\t}\n\n\tgetValue(): string {\n\t\treturn this.getValueOfRange(this.length.toRange());\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER)).length;\n\t}\n\n\tprivate _transformer: PositionOffsetTransformer | undefined = undefined;\n\n\tgetTransformer(): PositionOffsetTransformer {\n\t\tif (!this._transformer) {\n\t\t\tthis._transformer = new PositionOffsetTransformer(this.getValue());\n\t\t}\n\t\treturn this._transformer;\n\t}\n\n\tgetLineAt(lineNumber: number): string {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER));\n\t}\n\n\tgetLines(): string[] {\n\t\tconst value = this.getValue();\n\t\treturn splitLines(value);\n\t}\n}\n\nexport class LineBasedText extends AbstractText {\n\tconstructor(\n\t\tprivate readonly _getLineContent: (lineNumber: number) => string,\n\t\tprivate readonly _lineCount: number,\n\t) {\n\t\tassert(_lineCount >= 1);\n\n\t\tsuper();\n\t}\n\n\toverride getValueOfRange(range: Range): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\t\tlet result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n\t\tfor (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n\t\t\tresult += '\\n' + this._getLineContent(i);\n\t\t}\n\t\tresult += '\\n' + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n\t\treturn result;\n\t}\n\n\toverride getLineLength(lineNumber: number): number {\n\t\treturn this._getLineContent(lineNumber).length;\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLine = this._getLineContent(this._lineCount);\n\t\treturn new TextLength(this._lineCount - 1, lastLine.length);\n\t}\n}\n\nexport class ArrayText extends LineBasedText {\n\tconstructor(lines: string[]) {\n\t\tsuper(\n\t\t\tlineNumber => lines[lineNumber - 1],\n\t\t\tlines.length\n\t\t);\n\t}\n}\n\nexport class StringText extends AbstractText {\n\tprivate readonly _t = new PositionOffsetTransformer(this.value);\n\n\tconstructor(public readonly value: string) {\n\t\tsuper();\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\treturn this._t.getOffsetRange(range).substring(this.value);\n\t}\n\n\tget length(): TextLength {\n\t\treturn this._t.textLength;\n\t}\n}\n"]}