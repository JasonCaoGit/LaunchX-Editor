{"version":3,"sources":["file:///Users/kw/github/monaco-editor-core/out-editor-esm/vs/editor/common/tokens/tokenArray.ts","vs/editor/common/tokens/tokenArray.ts"],"names":[],"mappings":"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","file":"tokenArray.js","sourceRoot":"file:///Users/kw/github/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { ILanguageIdCodec } from '../languages.js';\nimport { LineTokens } from './lineTokens.js';\n\n/**\n * This class represents a sequence of tokens.\n * Conceptually, each token has a length and a metadata number.\n * A token array might be used to annotate a string with metadata.\n * Use {@link TokenArrayBuilder} to efficiently create a token array.\n *\n * TODO: Make this class more efficient (e.g. by using a Int32Array).\n*/\nexport class TokenArray {\n\tpublic static fromLineTokens(lineTokens: LineTokens): TokenArray {\n\t\tconst tokenInfo: TokenInfo[] = [];\n\t\tfor (let i = 0; i < lineTokens.getCount(); i++) {\n\t\t\ttokenInfo.push(new TokenInfo(lineTokens.getEndOffset(i) - lineTokens.getStartOffset(i), lineTokens.getMetadata(i)));\n\t\t}\n\t\treturn TokenArray.create(tokenInfo);\n\t}\n\n\tpublic static create(tokenInfo: TokenInfo[]): TokenArray {\n\t\treturn new TokenArray(tokenInfo);\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly _tokenInfo: TokenInfo[],\n\t) { }\n\n\tpublic toLineTokens(lineContent: string, decoder: ILanguageIdCodec): LineTokens {\n\t\treturn LineTokens.createFromTextAndMetadata(this.map((r, t) => ({ text: r.substring(lineContent), metadata: t.metadata })), decoder);\n\t}\n\n\tpublic forEach(cb: (range: OffsetRange, tokenInfo: TokenInfo) => void): void {\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst range = new OffsetRange(lengthSum, lengthSum + tokenInfo.length);\n\t\t\tcb(range, tokenInfo);\n\t\t\tlengthSum += tokenInfo.length;\n\t\t}\n\t}\n\n\tpublic map<T>(cb: (range: OffsetRange, tokenInfo: TokenInfo) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst range = new OffsetRange(lengthSum, lengthSum + tokenInfo.length);\n\t\t\tresult.push(cb(range, tokenInfo));\n\t\t\tlengthSum += tokenInfo.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic slice(range: OffsetRange): TokenArray {\n\t\tconst result: TokenInfo[] = [];\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst tokenStart = lengthSum;\n\t\t\tconst tokenEndEx = tokenStart + tokenInfo.length;\n\t\t\tif (tokenEndEx > range.start) {\n\t\t\t\tif (tokenStart >= range.endExclusive) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst deltaBefore = Math.max(0, range.start - tokenStart);\n\t\t\t\tconst deltaAfter = Math.max(0, tokenEndEx - range.endExclusive);\n\n\t\t\t\tresult.push(new TokenInfo(tokenInfo.length - deltaBefore - deltaAfter, tokenInfo.metadata));\n\t\t\t}\n\n\t\t\tlengthSum += tokenInfo.length;\n\t\t}\n\t\treturn TokenArray.create(result);\n\t}\n}\n\nexport type TokenMetadata = number;\n\nexport class TokenInfo {\n\tconstructor(\n\t\tpublic readonly length: number,\n\t\tpublic readonly metadata: TokenMetadata,\n\t) { }\n}\n\n/**\n * TODO: Make this class more efficient (e.g. by using a Int32Array).\n*/\nexport class TokenArrayBuilder {\n\tprivate readonly _tokens: TokenInfo[] = [];\n\n\tpublic add(length: number, metadata: TokenMetadata): void {\n\t\tthis._tokens.push(new TokenInfo(length, metadata));\n\t}\n\n\tpublic build(): TokenArray {\n\t\treturn TokenArray.create(this._tokens);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { ILanguageIdCodec } from '../languages.js';\nimport { LineTokens } from './lineTokens.js';\n\n/**\n * This class represents a sequence of tokens.\n * Conceptually, each token has a length and a metadata number.\n * A token array might be used to annotate a string with metadata.\n * Use {@link TokenArrayBuilder} to efficiently create a token array.\n *\n * TODO: Make this class more efficient (e.g. by using a Int32Array).\n*/\nexport class TokenArray {\n\tpublic static fromLineTokens(lineTokens: LineTokens): TokenArray {\n\t\tconst tokenInfo: TokenInfo[] = [];\n\t\tfor (let i = 0; i < lineTokens.getCount(); i++) {\n\t\t\ttokenInfo.push(new TokenInfo(lineTokens.getEndOffset(i) - lineTokens.getStartOffset(i), lineTokens.getMetadata(i)));\n\t\t}\n\t\treturn TokenArray.create(tokenInfo);\n\t}\n\n\tpublic static create(tokenInfo: TokenInfo[]): TokenArray {\n\t\treturn new TokenArray(tokenInfo);\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly _tokenInfo: TokenInfo[],\n\t) { }\n\n\tpublic toLineTokens(lineContent: string, decoder: ILanguageIdCodec): LineTokens {\n\t\treturn LineTokens.createFromTextAndMetadata(this.map((r, t) => ({ text: r.substring(lineContent), metadata: t.metadata })), decoder);\n\t}\n\n\tpublic forEach(cb: (range: OffsetRange, tokenInfo: TokenInfo) => void): void {\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst range = new OffsetRange(lengthSum, lengthSum + tokenInfo.length);\n\t\t\tcb(range, tokenInfo);\n\t\t\tlengthSum += tokenInfo.length;\n\t\t}\n\t}\n\n\tpublic map<T>(cb: (range: OffsetRange, tokenInfo: TokenInfo) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst range = new OffsetRange(lengthSum, lengthSum + tokenInfo.length);\n\t\t\tresult.push(cb(range, tokenInfo));\n\t\t\tlengthSum += tokenInfo.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic slice(range: OffsetRange): TokenArray {\n\t\tconst result: TokenInfo[] = [];\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst tokenStart = lengthSum;\n\t\t\tconst tokenEndEx = tokenStart + tokenInfo.length;\n\t\t\tif (tokenEndEx > range.start) {\n\t\t\t\tif (tokenStart >= range.endExclusive) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst deltaBefore = Math.max(0, range.start - tokenStart);\n\t\t\t\tconst deltaAfter = Math.max(0, tokenEndEx - range.endExclusive);\n\n\t\t\t\tresult.push(new TokenInfo(tokenInfo.length - deltaBefore - deltaAfter, tokenInfo.metadata));\n\t\t\t}\n\n\t\t\tlengthSum += tokenInfo.length;\n\t\t}\n\t\treturn TokenArray.create(result);\n\t}\n}\n\nexport type TokenMetadata = number;\n\nexport class TokenInfo {\n\tconstructor(\n\t\tpublic readonly length: number,\n\t\tpublic readonly metadata: TokenMetadata,\n\t) { }\n}\n\n/**\n * TODO: Make this class more efficient (e.g. by using a Int32Array).\n*/\nexport class TokenArrayBuilder {\n\tprivate readonly _tokens: TokenInfo[] = [];\n\n\tpublic add(length: number, metadata: TokenMetadata): void {\n\t\tthis._tokens.push(new TokenInfo(length, metadata));\n\t}\n\n\tpublic build(): TokenArray {\n\t\treturn TokenArray.create(this._tokens);\n\t}\n}\n"]}